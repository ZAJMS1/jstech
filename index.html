<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dystopian Escape</title>
    <link rel="stylesheet" href="css/styles.css">
    <!-- Updated to ES modules version of Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <style>
        #inventory-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 350px;
            background-color: rgba(20, 20, 40, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            display: none;
            z-index: 100;
            color: white;
            font-family: Arial, sans-serif;
            padding: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        }

        #inventory-title {
            text-align: center;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #666;
            font-size: 18px;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
            height: calc(100% - 60px);
        }

        .inventory-slot {
            background-color: rgba(40, 40, 60, 0.7);
            border: 1px solid #777;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .inventory-slot:hover {
            background-color: rgba(60, 60, 90, 0.8);
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(100, 100, 255, 0.5);
        }

        .inventory-slot img {
            max-width: 80%;
            max-height: 80%;
            pointer-events: none;
        }

        .item-tooltip {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .inventory-slot:hover .item-tooltip {
            opacity: 1;
            z-index: 20;
            bottom: -35px;
            background-color: rgba(10, 10, 30, 0.9);
            box-shadow: 0 0 8px rgba(100, 100, 255, 0.5);
            color: #fff;
            font-weight: bold;
            border: 1px solid #555;
        }

        .item-count {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 1px 4px;
            border-radius: 3px;
        }

        .key-tip {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 12px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="loading-screen">
            <div class="loading-text">Loading Dystopian World...</div>
        </div>
        <div id="info">
            <div class="controls-info">
                <p>WASD - Move | SPACE - Jump | MOUSE - Look | E - Inventory</p>
            </div>
        </div>
        <div id="debug"></div>
        <div id="inventory-panel">
            <h2 id="inventory-title">Inventory</h2>
            <div class="inventory-grid" id="inventory-grid"></div>
            <div class="key-tip">Press E to close</div>
        </div>

        <!-- Audio elements for ambient sounds -->
        <audio id="ambient-wind" loop preload="auto">
            <source src="https://assets.codepen.io/21542/howling-wind.mp3" type="audio/mp3">
        </audio>
        <audio id="distant-thunder" preload="auto">
            <source src="https://assets.codepen.io/21542/thunder.mp3" type="audio/mp3">
        </audio>
        <audio id="eerie-ambient" loop preload="auto">
            <source src="https://assets.codepen.io/21542/dark-ambience.mp3" type="audio/mp3">
        </audio>
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        
        window.onload = function() {
            const debugElement = document.getElementById('debug');
            
            try {
                // Hide loading screen
                document.getElementById('loading-screen').style.display = 'none';
                
                // Initialize audio
                initAudioEffects();
                
                // Game state
                const state = {
                    keysPressed: {},
                    playerVelocity: new THREE.Vector3(),
                    playerDirection: new THREE.Vector3(),
                    cameraOffset: new THREE.Vector3(0, 3, 7),
                    cameraRotation: { x: 0, y: 0 },
                    cameraMode: 'free', // Default camera mode: 'free' or 'shiftlock'
                    rightMouseDown: false,
                    mousePosition: { x: 0, y: 0 },
                    onGround: true,
                    movementSpeed: 0.15,
                    turnSpeed: 0.03,
                    jumpForce: 0.2,
                    gravity: 0.01,
                    animationState: 'idle',
                    timeSinceLastStep: 0,
                    lastInputTime: 0,
                    autoAlignDelay: 2, // Seconds to wait before auto-aligning camera
                    movingDirection: null, // Current moving direction
                    idleTime: 0,
                    lastHeadMove: 0,
                    headTargetRotation: null,
                    headMoveDuration: 0,
                    headMoveStart: 0,
                    jumpPhase: null,
                    jumpTime: 0,
                    landingComplete: false, // Track if landing animation has completed
                    inventory: {
                        isOpen: false,
                        items: [],
                        slots: 15,
                        slotElements: [],
                        initialized: false
                    }
                };
                
                // Initialize inventory system
                function initInventorySystem() {
                    // Only initialize once
                    if (state.inventory.initialized) return;
                    
                    // Mark as initialized
                    state.inventory.initialized = true;
                    
                    // Clear existing slots if any
                    const inventoryGrid = document.getElementById('inventory-grid');
                    if (!inventoryGrid) {
                        console.error("Inventory grid element not found!");
                        return;
                    }
                    
                    inventoryGrid.innerHTML = '';
                    state.inventory.slotElements = [];
                    
                    // Create inventory slots
                    for (let i = 0; i < state.inventory.slots; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'inventory-slot';
                        slot.dataset.index = i;
                        slot.innerHTML = `<div class="item-tooltip"></div>`;
                        
                        // Add click handler for using items
                        slot.addEventListener('click', () => {
                            const item = state.inventory.items[i];
                            if (item) {
                                // Handle item usage (can be expanded later)
                                console.log(`Used item: ${item.name}`);
                            }
                        });
                        
                        inventoryGrid.appendChild(slot);
                        state.inventory.slotElements.push(slot);
                    }
                    
                    // Add some test items to inventory
                    addItemToInventory({
                        name: "Health Potion",
                        description: "Restores 25 health points",
                        icon: "ðŸ§ª", // Using emoji for simplicity
                        count: 1
                    });
                    
                    addItemToInventory({
                        name: "Rusty Key",
                        description: "Might open something",
                        icon: "ðŸ”‘",
                        count: 1
                    });
                    
                    console.log("Inventory system initialized with", state.inventory.slots, "slots");
                }

                // Add item to inventory
                function addItemToInventory(item) {
                    // Check if item already exists
                    const existingItemIndex = state.inventory.items.findIndex(i => 
                        i && i.name === item.name);
                    
                    if (existingItemIndex >= 0 && state.inventory.items[existingItemIndex].stackable !== false) {
                        // Increment count for existing item
                        state.inventory.items[existingItemIndex].count += item.count || 1;
                        updateInventoryDisplay();
                        return true;
                    } else {
                        // Find empty slot
                        const emptySlotIndex = state.inventory.items.findIndex(i => !i);
                        
                        if (emptySlotIndex >= 0 && emptySlotIndex < state.inventory.slots) {
                            // Add to empty slot
                            state.inventory.items[emptySlotIndex] = item;
                            updateInventoryDisplay();
                            return true;
                        } else if (state.inventory.items.length < state.inventory.slots) {
                            // Add to new slot
                            state.inventory.items.push(item);
                            updateInventoryDisplay();
                            return true;
                        }
                    }
                    
                    // Inventory full
                    console.log("Inventory full!");
                    return false;
                }

                // Update inventory display
                function updateInventoryDisplay() {
                    if (!state.inventory.initialized) return;
                    
                    // Remove any existing floating tooltips
                    document.querySelectorAll('.floating-tooltip').forEach(el => el.remove());
                    
                    for (let i = 0; i < state.inventory.slots; i++) {
                        const slot = state.inventory.slotElements[i];
                        if (!slot) continue;
                        
                        const item = state.inventory.items[i];
                        
                        if (item) {
                            // Update slot with item info
                            slot.innerHTML = `<div>${item.icon}</div>
                                ${item.count > 1 ? `<div class="item-count">${item.count}</div>` : ''}`;
                            
                            // Add mouseover event to show tooltip
                            slot.onmouseover = () => {
                                const rect = slot.getBoundingClientRect();
                                const tooltip = document.createElement('div');
                                tooltip.className = 'floating-tooltip';
                                tooltip.textContent = item.name;
                                tooltip.style.position = 'absolute';
                                tooltip.style.left = (rect.left + rect.width/2) + 'px';
                                tooltip.style.top = (rect.bottom + 10) + 'px';
                                tooltip.style.transform = 'translateX(-50%)';
                                tooltip.style.backgroundColor = 'rgba(10, 10, 30, 0.9)';
                                tooltip.style.color = 'white';
                                tooltip.style.padding = '5px 10px';
                                tooltip.style.borderRadius = '5px';
                                tooltip.style.fontWeight = 'bold';
                                tooltip.style.boxShadow = '0 0 8px rgba(100, 100, 255, 0.5)';
                                tooltip.style.zIndex = '999';
                                tooltip.style.pointerEvents = 'none';
                                tooltip.style.border = '1px solid #555';
                                document.body.appendChild(tooltip);
                            };
                            
                            // Add mouseout event to hide tooltip
                            slot.onmouseout = () => {
                                document.querySelectorAll('.floating-tooltip').forEach(el => el.remove());
                            };
                        } else {
                            // Empty slot
                            slot.innerHTML = '';
                            slot.onmouseover = null;
                            slot.onmouseout = null;
                        }
                    }
                }

                // Toggle inventory display
                function toggleInventory() {
                    const inventoryPanel = document.getElementById('inventory-panel');
                    if (!inventoryPanel) {
                        console.error("Inventory panel element not found!");
                        return;
                    }
                    
                    state.inventory.isOpen = !state.inventory.isOpen;
                    console.log("Toggle inventory:", state.inventory.isOpen);
                    
                    if (state.inventory.isOpen) {
                        // Initialize inventory if not done yet (safety check)
                        if (!state.inventory.initialized) {
                            initInventorySystem();
                        }
                        
                        inventoryPanel.style.display = 'block';
                        updateInventoryDisplay();
                        console.log("Opened inventory");
                    } else {
                        inventoryPanel.style.display = 'none';
                        console.log("Closed inventory");
                    }
                }

                // Basic Three.js setup
                const scene = new THREE.Scene();
                
                // Update scene background and fog for a brighter ambiance
                scene.background = new THREE.Color(0x121212); // Dark background
                
                // Enhanced global fog - more realistic and denser outside, but still allows visibility
                scene.fog = new THREE.FogExp2(0x121212, 0.015); // Global fog with lower density to start
                
                // Create a secondary fog effect for outside areas only
                function adjustFogBasedOnPosition(playerPosition) {
                    // Increase fog density when player is outside (z > 25)
                    if (playerPosition.z > 25) {
                        scene.fog.density = 0.035; // Denser fog outside
                    } else {
                        scene.fog.density = 0.015; // Less dense fog inside
                    }
                }
                
                // Enhance ambient lighting - change to darker mood
                const ambientLight = new THREE.AmbientLight(0x334455, 0.4);
                scene.add(ambientLight);
                
                // Add directional light for natural moonlight effect
                const dirLight = new THREE.DirectionalLight(0x556677, 0.8);
                dirLight.position.set(30, 100, 30);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 1;
                dirLight.shadow.camera.far = 200;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                scene.add(dirLight);
                
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.getElementById('game-container').appendChild(renderer.domElement);
                
                // Create a house the player can walk around in
                const houseGroup = new THREE.Group();
                scene.add(houseGroup);
                
                // Materials library
                const materials = {
                    // Flooring
                    woodFloor: new THREE.MeshStandardMaterial({ 
                        color: 0x9b7653, 
                        roughness: 0.8,
                        metalness: 0.2
                    }),
                    tileFloor: new THREE.MeshStandardMaterial({ 
                        color: 0xd9d9d9, 
                        roughness: 0.7,
                        metalness: 0.1
                    }),
                    carpetFloor: new THREE.MeshStandardMaterial({ 
                        color: 0x496a81, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    
                    // Walls
                    wallExterior: new THREE.MeshStandardMaterial({ 
                        color: 0xe8e8e8, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    wallInterior: new THREE.MeshStandardMaterial({ 
                        color: 0xeaeaea, 
                        roughness: 0.9,
                        metalness: 0 
                    }),
                    
                    // Furniture
                    woodDark: new THREE.MeshStandardMaterial({ 
                        color: 0x5d4037, 
                        roughness: 0.8,
                        metalness: 0.1
                    }),
                    woodMedium: new THREE.MeshStandardMaterial({ 
                        color: 0x8d6e63, 
                        roughness: 0.8,
                        metalness: 0.1
                    }),
                    woodLight: new THREE.MeshStandardMaterial({ 
                        color: 0xbcaaa4, 
                        roughness: 0.8,
                        metalness: 0.1
                    }),
                    fabric: new THREE.MeshStandardMaterial({ 
                        color: 0x78909c, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    fabricDark: new THREE.MeshStandardMaterial({ 
                        color: 0x455a64, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    metal: new THREE.MeshStandardMaterial({ 
                        color: 0xb0bec5, 
                        roughness: 0.3,
                        metalness: 0.8
                    }),
                    glass: new THREE.MeshStandardMaterial({ 
                        color: 0xeceff1, 
                        roughness: 0.1,
                        metalness: 0.9,
                        transparent: true,
                        opacity: 0.3
                    }),
                    
                    // Roof
                    roofTiles: new THREE.MeshStandardMaterial({ 
                        color: 0x5d4037, 
                        roughness: 0.9,
                        metalness: 0.1
                    })
                };
                
                // House dimensions
                const houseDimensions = {
                    width: 50,
                    length: 50,
                    height: 15,
                    wallThickness: 1
                };
                
                // Door and window dimensions - use var to avoid redeclaration
                var frontDoorWidth = 6; // Increased door width
                var frontDoorHeight = 10; // Increased door height
                var frontWallHeight = houseDimensions.height * 0.9; // 90% of house height for interior walls
                var windowWidth = 5;
                var windowHeight = 5;
                
                // Create foundation - main floor
                const mainFloor = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        houseDimensions.width - 1, 
                        0.2, 
                        houseDimensions.length - 1
                    ),
                    materials.wallInterior
                );
                mainFloor.position.y = 0; // Position at ground level
                mainFloor.receiveShadow = true;
                houseGroup.add(mainFloor);
                
                // Create ceiling - separate from the floor
                const ceiling = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        houseDimensions.width - 1, 
                        0.2, 
                        houseDimensions.length - 1
                    ),
                    materials.wallInterior
                );
                ceiling.position.y = houseDimensions.height;
                ceiling.receiveShadow = true;
                houseGroup.add(ceiling);
                
                // Function to create wall sections
                function createWallSection(width, height, depth, x, y, z, material) {
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(width, height, depth),
                        material
                    );
                    wall.position.set(x, y, z);
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    wall.userData.collidable = true; // Mark as collidable
                    return wall;
                }
                
                // Create outer walls
                // Back wall (full wall)
                const backWall = createWallSection(
                    houseDimensions.width, 
                    houseDimensions.height, 
                    houseDimensions.wallThickness,
                    0, 
                    houseDimensions.height / 2, 
                    -houseDimensions.length / 2,
                    materials.wallExterior
                );
                houseGroup.add(backWall);
                
                // Left wall
                const leftWall = createWallSection(
                    houseDimensions.wallThickness, 
                    houseDimensions.height, 
                    houseDimensions.length,
                    -houseDimensions.width / 2, 
                    houseDimensions.height / 2, 
                    0,
                    materials.wallExterior
                );
                houseGroup.add(leftWall);
                
                // Right wall
                const rightWall = createWallSection(
                    houseDimensions.wallThickness, 
                    houseDimensions.height, 
                    houseDimensions.length,
                    houseDimensions.width / 2, 
                    houseDimensions.height / 2, 
                    0,
                    materials.wallExterior
                );
                houseGroup.add(rightWall);
                
                // Front wall with door opening
                // Left section
                const frontWallLeft = createWallSection(
                    (houseDimensions.width - frontDoorWidth) / 2, 
                    houseDimensions.height, 
                    houseDimensions.wallThickness,
                    -houseDimensions.width / 4 - frontDoorWidth / 4, 
                    houseDimensions.height / 2, 
                    houseDimensions.length / 2,
                    materials.wallExterior
                );
                houseGroup.add(frontWallLeft);
                
                // Right section
                const frontWallRight = createWallSection(
                    (houseDimensions.width - frontDoorWidth) / 2, 
                    houseDimensions.height, 
                    houseDimensions.wallThickness,
                    houseDimensions.width / 4 + frontDoorWidth / 4, 
                    houseDimensions.height / 2, 
                    houseDimensions.length / 2,
                    materials.wallExterior
                );
                houseGroup.add(frontWallRight);
                
                // Top section
                const frontWallTop = createWallSection(
                    frontDoorWidth, 
                    houseDimensions.height - frontDoorHeight, 
                    houseDimensions.wallThickness,
                    0, 
                    houseDimensions.height - (houseDimensions.height - frontDoorHeight) / 2, 
                    houseDimensions.length / 2,
                    materials.wallExterior
                );
                houseGroup.add(frontWallTop);
                
                // Add windows
                function createWindow(width, height, x, y, z, rotationY) {
                    const windowGroup = new THREE.Group();
                    
                    // Window glass
                    const windowPane = new THREE.Mesh(
                        new THREE.PlaneGeometry(width, height),
                        materials.glass
                    );
                    windowPane.position.set(0, 0, 0.05);
                    windowGroup.add(windowPane);
                    
                    // Window frame
                    const frameWidth = 0.3;
                    
                    // Top frame
                    const topFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(width + frameWidth * 2, frameWidth, 0.2),
                        materials.woodDark
                    );
                    topFrame.position.set(0, height / 2 + frameWidth / 2, 0);
                    windowGroup.add(topFrame);
                    
                    // Bottom frame
                    const bottomFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(width + frameWidth * 2, frameWidth, 0.2),
                        materials.woodDark
                    );
                    bottomFrame.position.set(0, -height / 2 - frameWidth / 2, 0);
                    windowGroup.add(bottomFrame);
                    
                    // Left frame
                    const leftFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth, height, 0.2),
                        materials.woodDark
                    );
                    leftFrame.position.set(-width / 2 - frameWidth / 2, 0, 0);
                    windowGroup.add(leftFrame);
                    
                    // Right frame
                    const rightFrame = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth, height, 0.2),
                        materials.woodDark
                    );
                    rightFrame.position.set(width / 2 + frameWidth / 2, 0, 0);
                    windowGroup.add(rightFrame);
                    
                    // Middle crossbar - horizontal
                    const middleHBar = new THREE.Mesh(
                        new THREE.BoxGeometry(width, frameWidth, 0.2),
                        materials.woodDark
                    );
                    middleHBar.position.set(0, 0, 0);
                    windowGroup.add(middleHBar);
                    
                    // Middle crossbar - vertical
                    const middleVBar = new THREE.Mesh(
                        new THREE.BoxGeometry(frameWidth, height, 0.2),
                        materials.woodDark
                    );
                    middleVBar.position.set(0, 0, 0);
                    windowGroup.add(middleVBar);
                    
                    // Position the window group
                    windowGroup.position.set(x, y, z);
                    windowGroup.rotation.y = rotationY || 0;
                    
                    return windowGroup;
                }
                
                // Add windows to the house
                // Front windows
                const frontWindowLeft = createWindow(
                    6, 5, 
                    -12, 6, 
                    houseDimensions.length / 2 + 0.1, 
                    0
                );
                houseGroup.add(frontWindowLeft);
                
                const frontWindowRight = createWindow(
                    6, 5, 
                    12, 6, 
                    houseDimensions.length / 2 + 0.1, 
                    0
                );
                houseGroup.add(frontWindowRight);
                
                // Side windows
                const leftWindowFront = createWindow(
                    6, 5, 
                    -houseDimensions.width / 2 - 0.1, 6, 
                    15, 
                    Math.PI / 2
                );
                houseGroup.add(leftWindowFront);
                
                const leftWindowBack = createWindow(
                    6, 5, 
                    -houseDimensions.width / 2 - 0.1, 6, 
                    -15, 
                    Math.PI / 2
                );
                houseGroup.add(leftWindowBack);
                
                const rightWindowFront = createWindow(
                    6, 5, 
                    houseDimensions.width / 2 + 0.1, 6, 
                    15, 
                    -Math.PI / 2
                );
                houseGroup.add(rightWindowFront);
                
                const rightWindowBack = createWindow(
                    6, 5, 
                    houseDimensions.width / 2 + 0.1, 6, 
                    -15, 
                    -Math.PI / 2
                );
                houseGroup.add(rightWindowBack);
                
                // Back windows
                const backWindowLeft = createWindow(
                    6, 5, 
                    -12, 6, 
                    -houseDimensions.length / 2 - 0.1, 
                    Math.PI
                );
                houseGroup.add(backWindowLeft);
                
                const backWindowMiddle = createWindow(
                    6, 5, 
                    0, 6, 
                    -houseDimensions.length / 2 - 0.1, 
                    Math.PI
                );
                houseGroup.add(backWindowMiddle);
                
                const backWindowRight = createWindow(
                    6, 5, 
                    12, 6, 
                    -houseDimensions.length / 2 - 0.1, 
                    Math.PI
                );
                houseGroup.add(backWindowRight);
                
                // Furniture
                // Table
                const smallTableHeight = 0.8;
                const smallTableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 1.2),
                    materials.woodMedium
                );
                smallTableTop.position.set(-2, smallTableHeight, -2);
                smallTableTop.castShadow = true;
                houseGroup.add(smallTableTop);
                
                // Table legs
                for (let x = -1; x <= 1; x += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        const tableLeg = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.05, smallTableHeight),
                            materials.woodDark
                        );
                        tableLeg.position.set(-2 + x * 0.9, smallTableHeight / 2, -2 + z * 0.5);
                        tableLeg.castShadow = true;
                        houseGroup.add(tableLeg);
                    }
                }
                
                // Chairs
                function createChair(x, z, rotation) {
                    const chairGroup = new THREE.Group();
                    chairGroup.position.set(x, 0, z);
                    chairGroup.rotation.y = rotation;
                    
                    // Seat
                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.1, 0.6),
                        materials.woodMedium
                    );
                    seat.position.y = 0.45;
                    seat.castShadow = true;
                    chairGroup.add(seat);
                    
                    // Backrest
                    const back = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.5, 0.1),
                        materials.woodDark
                    );
                    back.position.set(0, 0.7, -0.25);
                    back.castShadow = true;
                    chairGroup.add(back);
                    
                    // Legs
                    for (let i = -1; i <= 1; i += 2) {
                        for (let j = -1; j <= 1; j += 2) {
                            const leg = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.04, 0.04, 0.45),
                                materials.woodDark
                            );
                            leg.position.set(i * 0.25, 0.225, j * 0.25);
                            leg.castShadow = true;
                            chairGroup.add(leg);
                        }
                    }
                    
                    return chairGroup;
                }
                
                houseGroup.add(createChair(-2, -3, 0));  // Front
                houseGroup.add(createChair(-2, -1, Math.PI));  // Back
                houseGroup.add(createChair(-3, -2, Math.PI/2));  // Left
                houseGroup.add(createChair(-1, -2, -Math.PI/2));  // Right
                
                // Bed
                const smallBedFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.3, 3),
                    materials.woodMedium
                );
                smallBedFrame.position.set(3, 0.15, -2);
                smallBedFrame.castShadow = true;
                houseGroup.add(smallBedFrame);
                
                // Mattress
                const smallMattress = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.3, 2.8),
                    materials.fabric
                );
                smallMattress.position.set(3, 0.45, -2);
                smallMattress.castShadow = true;
                houseGroup.add(smallMattress);
                
                // Pillow
                const pillow = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 0.2, 0.6),
                    materials.fabric
                );
                pillow.position.set(3, 0.7, -3.1);
                pillow.castShadow = true;
                houseGroup.add(pillow);
                
                // Blanket
                const smallBlanket = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.1, 1.4),
                    materials.fabric
                );
                smallBlanket.position.set(3, 0.65, -1.4);
                smallBlanket.castShadow = true;
                houseGroup.add(smallBlanket);
                
                // Bookshelf
                const bookshelf = new THREE.Group();
                bookshelf.position.set(3, 0, -houseDimensions.length / 2 + 0.6);
                
                // Bookshelf frame
                const shelfFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2.5, 0.5),
                    materials.woodDark
                );
                bookshelf.add(shelfFrame);
                
                // Bookshelf back
                const shelfBack = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2.5, 0.05),
                    materials.woodDark
                );
                shelfBack.position.z = -0.225;
                bookshelf.add(shelfBack);
                
                // Bookshelf sides
                const leftSide = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 2.5, 0.5),
                    materials.woodDark
                );
                leftSide.position.x = -0.975;
                bookshelf.add(leftSide);
                
                const rightSide = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 2.5, 0.5),
                    materials.woodDark
                );
                rightSide.position.x = 0.975;
                bookshelf.add(rightSide);
                
                // Bookshelf shelves
                for (let i = 0; i < 5; i++) {
                    const shelf = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.05, 0.5),
                        materials.woodDark
                    );
                    shelf.position.y = -1.25 + i * 0.625;
                    bookshelf.add(shelf);
                    
                    // Add books on shelves
                    if (i > 0) {
                        const numBooks = Math.floor(Math.random() * 5) + 3;
                        const shelfWidth = 1.9;
                        const bookWidth = shelfWidth / numBooks;
                        
                        for (let j = 0; j < numBooks; j++) {
                            if (Math.random() > 0.25) { // Some gaps in the shelves
                                const bookHeight = 0.3 + Math.random() * 0.2;
                                const book = new THREE.Mesh(
                                    new THREE.BoxGeometry(bookWidth * 0.8, bookHeight, 0.2),
                                    new THREE.MeshStandardMaterial({ 
                                        color: new THREE.Color(
                                            Math.random() * 0.8, 
                                            Math.random() * 0.8, 
                                            Math.random() * 0.8
                                        ) 
                                    })
                                );
                                book.position.set(
                                    -0.95 + j * bookWidth + bookWidth / 2,
                                    -1.25 + i * 0.625 + bookHeight / 2 + 0.025,
                                    -0.1
                                );
                                book.castShadow = true;
                                bookshelf.add(book);
                            }
                        }
                    }
                }
                
                houseGroup.add(bookshelf);
                
                // Add interior lighting
                const pointLight = new THREE.PointLight(0xffbb77, 0.8, 15);
                pointLight.position.set(0, houseDimensions.height - 0.5, 0);
                pointLight.castShadow = true;
                pointLight.shadow.mapSize.width = 1024;
                pointLight.shadow.mapSize.height = 1024;
                houseGroup.add(pointLight);
                
                // Add light "fixtures"
                const lightFixture = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffcc88, emissive: 0xffcc88, emissiveIntensity: 0.5 })
                );
                lightFixture.position.copy(pointLight.position);
                houseGroup.add(lightFixture);
                
                // Position the player inside the house
                const player = createLowPolyCharacter();
                player.position.set(0, 1, 25); // Near the front door, inside the house
                scene.add(player);
                
                // Create outside environment
                createOutsideEnvironment();
                
                // Function to create the outside dystopian environment
                function createOutsideEnvironment() {
                    // Create outside group
                    const outsideGroup = new THREE.Group();
                    outsideGroup.name = 'outsideGroup';
                    scene.add(outsideGroup);
                    
                    // Add atmospheric lighting for the outside
                    const moonLight = new THREE.DirectionalLight(0x334455, 0.3);
                    moonLight.position.set(-50, 80, -30);
                    moonLight.castShadow = true;
                    moonLight.shadow.mapSize.width = 2048;
                    moonLight.shadow.mapSize.height = 2048;
                    moonLight.shadow.camera.near = 1;
                    moonLight.shadow.camera.far = 300;
                    moonLight.shadow.camera.left = -100;
                    moonLight.shadow.camera.right = 100;
                    moonLight.shadow.camera.top = 100;
                    moonLight.shadow.camera.bottom = -100;
                    scene.add(moonLight);
                    
                    // Add some eerie flickering lights in the distance
                    for (let i = 0; i < 8; i++) {
                        const flickerLight = new THREE.PointLight(
                            // Random colors between orange/red (fire-like) and cold blue
                            Math.random() > 0.6 ? 0xff3300 : 0x0066aa,
                            0.8,
                            150
                        );
                        
                        // Position lights in the far distance
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 100 + Math.random() * 100;
                        flickerLight.position.set(
                            Math.sin(angle) * distance,
                            2 + Math.random() * 10,
                            Math.cos(angle) * distance
                        );
                        
                        // Create flickering animation
                        const flickerSpeed = 0.05 + Math.random() * 0.2;
                        const flickerIntensity = 0.2 + Math.random() * 0.8;
                        const baseIntensity = flickerLight.intensity;
                        
                        // Store animation data with the light
                        flickerLight.userData = {
                            flickerSpeed,
                            flickerIntensity,
                            baseIntensity,
                            timeOffset: Math.random() * 1000
                        };
                        
                        scene.add(flickerLight);
                        
                        // Add to list of lights to animate
                        if (!window.flickeringLights) window.flickeringLights = [];
                        window.flickeringLights.push(flickerLight);
                    }
                    
                    // Materials for outside elements
                    const materials = {
                        dirtyPath: new THREE.MeshStandardMaterial({
                            color: 0x333333,
                            roughness: 0.9,
                            metalness: 0.1
                        }),
                        deadGrass: new THREE.MeshStandardMaterial({
                            color: 0x2a2a1a,
                            roughness: 0.95,
                            metalness: 0
                        }),
                        metal: new THREE.MeshStandardMaterial({
                            color: 0x665544,
                            roughness: 0.7,
                            metalness: 0.6
                        }),
                        rustyMetal: new THREE.MeshStandardMaterial({
                            color: 0x554433,
                            roughness: 0.8,
                            metalness: 0.4
                        }),
                        deadWood: new THREE.MeshStandardMaterial({
                            color: 0x443322,
                            roughness: 0.9,
                            metalness: 0.1
                        }),
                        glass: new THREE.MeshStandardMaterial({
                            color: 0xaaaaaa,
                            roughness: 0.2,
                            metalness: 0.8,
                            transparent: true,
                            opacity: 0.3
                        }),
                        brokenGlass: new THREE.MeshStandardMaterial({
                            color: 0x777777,
                            roughness: 0.5,
                            metalness: 0.5,
                            transparent: true,
                            opacity: 0.2
                        })
                    };
                    
                    // Create large ground plane
                    const groundSize = 500;
                    const ground = new THREE.Mesh(
                        new THREE.PlaneGeometry(groundSize, groundSize),
                        materials.deadGrass
                    );
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.y = -0.1;
                    ground.receiveShadow = true;
                    outsideGroup.add(ground);
                    
                    // Create path leading to the house
                    const pathWidth = 5;
                    const pathLength = 200;
                    const path = new THREE.Mesh(
                        new THREE.PlaneGeometry(pathWidth, pathLength),
                        materials.dirtyPath
                    );
                    path.rotation.x = -Math.PI / 2;
                    path.position.set(0, 0.01, pathLength/2 - 20);
                    path.receiveShadow = true;
                    outsideGroup.add(path);
                    
                    // Add cracks and details to the path using small meshes
                    for (let i = 0; i < 40; i++) {
                        const crackSize = Math.random() * 1.5 + 0.5;
                        const crack = new THREE.Mesh(
                            new THREE.PlaneGeometry(crackSize, crackSize),
                            new THREE.MeshStandardMaterial({
                                color: 0x222222,
                                roughness: 1.0,
                                metalness: 0.0
                            })
                        );
                        crack.rotation.x = -Math.PI / 2;
                        crack.position.set(
                            (Math.random() - 0.5) * pathWidth * 0.8,
                            0.02,
                            (Math.random() * pathLength) - 20
                        );
                        crack.receiveShadow = true;
                        outsideGroup.add(crack);
                    }
                    
                    // Add street lights along the path (broken/shattered)
                    const streetLightCount = 20;
                    const streetLightSpacing = 15;
                    
                    for (let i = 0; i < streetLightCount; i++) {
                        // Alternate sides of the path
                        const side = i % 2 === 0 ? 1 : -1;
                        
                        // Create street light post and add tilt for damaged effect
                        const tiltAngle = (Math.random() - 0.5) * 0.5;
                        const postHeight = 5 + Math.random() * 2;
                        
                        const post = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.3, postHeight, 8),
                            materials.rustyMetal
                        );
                        
                        // Calculate position, ensuring z > 25 (outside the house) hhgggasdfasdfasdf
                        const zPosition = Math.max(25, i * streetLightSpacing - 10);
                        
                        // Position with variation and tilt wertgwertjh
                        post.position.set(
                            side * (pathWidth/2 + 1 + Math.random()),
                            postHeight/2,
                            zPosition
                        );
                        
                        // Apply tilt
                        post.rotation.z = tiltAngle;
                        if (Math.random() < 0.2) {
                            // Some posts are severely tilted
                            post.rotation.z = (Math.random() - 0.5) * 1.5;
                        }
                        
                        post.castShadow = true;
                        post.receiveShadow = true;
                        outsideGroup.add(post);
                        
                        // Lamp head with broken glass
                        if (Math.random() > 0.3) { // Some lights are completely missing
                            const lampHead = new THREE.Group();
                            
                            // Lamp housing
                            const housing = new THREE.Mesh(
                                new THREE.BoxGeometry(0.8, 0.5, 1.2),
                                materials.rustyMetal
                            );
                            
                            // Some lamp heads are damaged/dented
                            if (Math.random() > 0.5) {
                                housing.scale.set(
                                    1.0,
                                    1.0 - Math.random() * 0.4,
                                    1.0 - Math.random() * 0.3
                                );
                            }
                            
                            lampHead.add(housing);
                            
                            // Broken glass
                            if (Math.random() > 0.4) { // Some have no glass left
                                const glass = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.7, 0.4, 1.1),
                                    Math.random() > 0.5 ? materials.brokenGlass : materials.glass
                                );
                                glass.position.y = -0.05;
                                lampHead.add(glass);
                                
                                // Add a dim light to some working lamps
                                if (Math.random() < 0.2) {
                                    const light = new THREE.PointLight(0xaaaaaa, 0.5, 10);
                                    light.position.y = -0.2;
                                    lampHead.add(light);
                                }
                            }
                            
                            // Attach lamp to post
                            lampHead.position.set(0, postHeight, 0);
                            
                            // Random rotations for damaged/hanging lamps
                            if (Math.random() > 0.3) {
                                lampHead.rotation.x = (Math.random() - 0.5) * 0.6;
                                lampHead.rotation.z = (Math.random() - 0.5) * 0.4;
                            }
                            
                            post.add(lampHead);
                        }
                    }
                    
                    // Add dead trees and plants
                    for (let i = 0; i < 80; i++) {
                        const treeGroup = new THREE.Group();
                        
                        // Distance from path
                        const distFromPath = 3 + Math.random() * 40;
                        const side = Math.random() > 0.5 ? 1 : -1;
                        
                        // Tree trunk
                        const trunkHeight = 4 + Math.random() * 10;
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(
                                0.3 + Math.random() * 0.5,
                                0.5 + Math.random() * 0.7,
                                trunkHeight,
                                8
                            ),
                            materials.deadWood
                        );
                        trunk.position.y = trunkHeight / 2;
                        trunk.castShadow = true;
                        trunk.receiveShadow = true;
                        trunk.userData.collidable = true; // Mark as collidable
                        
                        // Add tilt for a creepy effect
                        trunk.rotation.z = (Math.random() - 0.5) * 0.4;
                        trunk.rotation.x = (Math.random() - 0.5) * 0.2;
                        
                        treeGroup.add(trunk);
                        
                        // Only larger trees get branches
                        if (trunkHeight > 7) {
                            // Add some twisted branches
                            const branchCount = Math.floor(Math.random() * 5) + 2;
                            
                            for (let j = 0; j < branchCount; j++) {
                                const branchLength = 1 + Math.random() * 4;
                                const branch = new THREE.Mesh(
                                    new THREE.CylinderGeometry(
                                        0.15,
                                        0.3,
                                        branchLength,
                                        6
                                    ),
                                    materials.deadWood
                                );
                                
                                // Position branch
                                const branchHeight = (Math.random() * 0.6 + 0.3) * trunkHeight;
                                branch.position.y = branchHeight - trunk.position.y;
                                
                                // Rotate to horizontal-ish position
                                branch.rotation.z = (Math.random() - 0.5) * Math.PI;
                                branch.rotation.y = Math.random() * Math.PI * 2;
                                
                                // Shift branch end position
                                branch.position.x = Math.sin(branch.rotation.z) * branchLength/2;
                                branch.position.y += Math.cos(branch.rotation.z) * branchLength/2;
                                
                                branch.castShadow = true;
                                trunk.add(branch);
                            }
                        }
                        
                        // Position the tree - ENSURE TREES ARE OUTSIDE THE HOUSE (z > 25)
                        // Generate a z position until we get one that's outside the house
                        let zPos;
                        do {
                            zPos = Math.random() * pathLength * 1.2 - 20;
                        } while (zPos < 25); // Keep regenerating until we get z > 25
                        
                        treeGroup.position.set(
                            side * (pathWidth/2 + distFromPath),
                            0,
                            zPos
                        );
                        
                        outsideGroup.add(treeGroup);
                    }
                    
                    // Add dead bushes and smaller vegetation
                    for (let i = 0; i < 150; i++) {
                        // Small dead bush
                        const bushSize = 0.5 + Math.random() * 1.5;
                        const bushHeight = 0.3 + Math.random() * 1.2;
                        
                        // Use an irregular shape for bushes
                        const bushGeometry = new THREE.SphereGeometry(
                            bushSize,
                            Math.floor(3 + Math.random() * 4),
                            Math.floor(2 + Math.random() * 3)
                        );
                        
                        // Deform the bush mesh to look dead and irregular
                        const bushVertices = bushGeometry.attributes.position;
                        for (let j = 0; j < bushVertices.count; j++) {
                            const x = bushVertices.getX(j);
                            const y = bushVertices.getY(j);
                            const z = bushVertices.getZ(j);
                            
                            const distort = (Math.random() - 0.5) * 0.4;
                            
                            bushVertices.setX(j, x * (1 + distort));
                            bushVertices.setZ(j, z * (1 + distort));
                            bushVertices.setY(j, y * (1 + (Math.random() - 0.2) * 0.5));
                        }
                        
                        // Create a variation of the dead grass material for bushes
                        const bushColor = new THREE.Color(0x2a2a1a);
                        bushColor.r += (Math.random() - 0.5) * 0.1;
                        bushColor.g += (Math.random() - 0.5) * 0.1;
                        
                        const bushMaterial = new THREE.MeshStandardMaterial({
                            color: bushColor,
                            roughness: 0.9,
                            metalness: 0.1
                        });
                        
                        const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                        
                        // Position with large spread - ENSURE BUSHES ARE OUTSIDE THE HOUSE (z > 25)
                        const distFromPath = 3 + Math.random() * 100;
                        const side = Math.random() > 0.5 ? 1 : -1;
                        
                        // Generate a z position until we get one that's outside the house
                        let zPos;
                        do {
                            zPos = (Math.random() * pathLength * 2) - pathLength/2;
                        } while (zPos < 25); // Keep regenerating until we get z > 25
                        
                        bush.position.set(
                            side * (pathWidth/2 + distFromPath),
                            bushHeight/2,
                            zPos
                        );
                        
                        bush.castShadow = true;
                        bush.receiveShadow = true;
                        outsideGroup.add(bush);
                    }
                    
                    // Add some scattered debris and trash
                    const debrisTypes = [
                        // Metal scraps
                        {
                            geometry: new THREE.BoxGeometry(
                                Math.random() * 2 + 0.5,
                                Math.random() * 0.5 + 0.1,
                                Math.random() * 2 + 0.5
                            ),
                            material: materials.rustyMetal,
                            quantity: 30
                        },
                        // Concrete chunks
                        {
                            geometry: new THREE.DodecahedronGeometry(
                                Math.random() * 1.5 + 0.5,
                                0
                            ),
                            material: new THREE.MeshStandardMaterial({
                                color: 0x444444,
                                roughness: 0.9,
                                metalness: 0.1
                            }),
                            quantity: 25
                        },
                        // Broken wooden planks
                        {
                            geometry: new THREE.BoxGeometry(
                                Math.random() * 3 + 1,
                                Math.random() * 0.3 + 0.1,
                                Math.random() * 0.5 + 0.2
                            ),
                            material: materials.deadWood,
                            quantity: 20
                        }
                    ];
                    
                    // Add the debris
                    debrisTypes.forEach(debrisType => {
                        for (let i = 0; i < debrisType.quantity; i++) {
                            const geometry = debrisType.geometry.clone();
                            
                            // Randomize geometry scale slightly
                            const scale = 0.5 + Math.random() * 1.5;
                            
                            const debris = new THREE.Mesh(
                                geometry,
                                debrisType.material
                            );
                            
                            // Position within reasonable distance from path
                            const distFromPath = Math.random() * 30;
                            const side = Math.random() > 0.5 ? 1 : -1;
                            
                            // Generate a z position until we get one that's outside the house (z > 25)
                            let zPos;
                            do {
                                zPos = (Math.random() * pathLength * 1.5) - 30;
                            } while (zPos < 25); // Keep regenerating until we get z > 25
                            
                            debris.position.set(
                                side * (pathWidth/2 + distFromPath),
                                0.1 + Math.random() * 0.3,
                                zPos
                            );
                            
                            // Random rotation for natural look
                            debris.rotation.x = Math.random() * Math.PI;
                            debris.rotation.y = Math.random() * Math.PI;
                            debris.rotation.z = Math.random() * Math.PI;
                            
                            debris.scale.set(scale, scale, scale);
                            debris.castShadow = true;
                            debris.receiveShadow = true;
                            outsideGroup.add(debris);
                        }
                    });
                    
                    // Add atmospheric distance haze instead of particle fog
                    // This is a subtle effect using lighting rather than moving planes
                    for (let i = 0; i < 5; i++) {
                        const zDistance = 50 + i * 30; // Increasingly further out
                        const fogLight = new THREE.PointLight(0x223344, 0.3, 100);
                        
                        // Position lights at varying distances down the path
                        fogLight.position.set(
                            (Math.random() - 0.5) * 40,
                            3 + Math.random() * 5,
                            zDistance
                        );
                        
                        outsideGroup.add(fogLight);
                    }
                }
                
                // Remove this line from the original code since we've already positioned the player
                // scene.add(player);
                
                // First-person controls variables
                let moveForward = false;
                let moveBackward = false;
                let moveLeft = false;
                let moveRight = false;
                let canJump = true;
                
                // Lock and hide cursor
                const blocker = document.createElement('div');
                blocker.id = 'blocker';
                blocker.style.position = 'absolute';
                blocker.style.width = '100%';
                blocker.style.height = '100%';
                blocker.style.backgroundColor = 'rgba(0,0,0,0.5)';
                blocker.style.display = 'flex';
                blocker.style.justifyContent = 'center';
                blocker.style.alignItems = 'center';
                blocker.style.zIndex = '999';
                blocker.innerHTML = '<div style="color:white;font-size:24px;">Click to play</div>';
                document.body.appendChild(blocker);
                
                setupControls();
                
                function createLowPolyCharacter() {
                    // Create a group for the character
                    const character = new THREE.Group();
                    
                    // Create body parts with more rounded geometric shapes
                    
                    // Body - torso with curved shape
                    const torsoGeom = new THREE.CylinderGeometry(0.6, 0.5, 1.7, 8);
                    const torsoMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    const torso = new THREE.Mesh(torsoGeom, torsoMat);
                    torso.position.y = 1.2;
                    torso.castShadow = true;
                    character.add(torso);
                    character.torso = torso; // Reference for animations
                    
                    // Add shoulders - wider at the top
                    const shouldersGeom = new THREE.CylinderGeometry(0.7, 0.6, 0.4, 8);
                    const shouldersMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    const shoulders = new THREE.Mesh(shouldersGeom, shouldersMat);
                    shoulders.position.y = 2.0;
                    shoulders.castShadow = true;
                    character.add(shoulders);
                    character.shoulders = shoulders; // Reference for animations
                    
                    // Hip section
                    const hipGeom = new THREE.CylinderGeometry(0.5, 0.55, 0.3, 8);
                    const hipMat = new THREE.MeshStandardMaterial({ color: 0x222266, roughness: 0.7 });
                    const hip = new THREE.Mesh(hipGeom, hipMat);
                    hip.position.y = 0.5;
                    hip.castShadow = true;
                    character.add(hip);
                    
                    // Change the hair implementation to anchor it to the head
                    // Create a head group to contain all head parts
                    const headGroup = new THREE.Group();
                    headGroup.position.y = 2.5;
                    character.add(headGroup);
                    character.headGroup = headGroup;
                    
                    // Add the head to the head group with adjusted local position - make more spherical
                    const headGeom = new THREE.SphereGeometry(0.48, 16, 16);
                    const headMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 });
                    const head = new THREE.Mesh(headGeom, headMat);
                    head.position.y = 0; // Local position relative to headGroup
                    head.scale.set(1, 1.02, 0.95); // Very slight adjustments for natural look
                    head.castShadow = true;
                    headGroup.add(head);
                    character.head = head; // Reference for animations
                    
                    // Neck - positioned relative to character, not in head group
                    const neckGeom = new THREE.CylinderGeometry(0.25, 0.3, 0.3, 8);
                    const neckMat = new THREE.MeshStandardMaterial({ color: 0xdda688, roughness: 0.5 });
                    const neck = new THREE.Mesh(neckGeom, neckMat);
                    neck.position.y = 2.2;
                    neck.castShadow = true;
                    character.add(neck);
                    
                    // Hair - more spherical shape but stopping at forehead
                    const hairTopGeom = new THREE.SphereGeometry(0.52, 16, 16);
                    const hairMat = new THREE.MeshStandardMaterial({ color: 0x553322, roughness: 0.9 });
                    const hairTop = new THREE.Mesh(hairTopGeom, hairMat);
                    hairTop.position.y = 0.15; // Slightly elevated position
                    hairTop.position.z = -0.07; // Pull hair back from face
                    hairTop.scale.set(1, 0.85, 0.85); // Reduced depth to prevent forward extension
                    headGroup.add(hairTop);
                    
                    // Hair sides - more rounded with sphere geometry, also pulled back
                    const hairSideGeom = new THREE.SphereGeometry(0.52, 12, 12);
                    const hairSides = new THREE.Mesh(hairSideGeom, hairMat);
                    hairSides.position.set(0, 0.05, -0.1); // Positioned further back
                    hairSides.scale.set(1, 0.4, 0.7); // Reduced depth for sides
                    headGroup.add(hairSides);
                    
                    // Eyes and other facial features added to the head group
                    // Left eye white
                    const eyeWhiteGeom = new THREE.SphereGeometry(0.1, 10, 10);
                    const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const leftEyeWhite = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
                    leftEyeWhite.position.set(0.2, 0.05, 0.43);
                    headGroup.add(leftEyeWhite);
                    
                    // Left eye pupil
                    const eyeGeom = new THREE.SphereGeometry(0.08, 8, 8);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                    leftEye.position.set(0.2, 0.05, 0.49);
                    headGroup.add(leftEye);
                    character.leftEye = leftEye; // Reference for animations
                    
                    // Right eye white
                    const rightEyeWhite = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
                    rightEyeWhite.position.set(-0.2, 0.05, 0.43);
                    headGroup.add(rightEyeWhite);
                    
                    // Right eye pupil
                    const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                    rightEye.position.set(-0.2, 0.05, 0.49);
                    headGroup.add(rightEye);
                    character.rightEye = rightEye; // Reference for animations
                    
                    // Eyelids
                    const eyelidGeom = new THREE.SphereGeometry(0.11, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const eyelidMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 });
                    
                    const leftEyelid = new THREE.Mesh(eyelidGeom, eyelidMat);
                    leftEyelid.position.set(0.2, 0.07, 0.43);
                    leftEyelid.rotation.x = Math.PI / 2;
                    headGroup.add(leftEyelid);
                    character.leftEyelid = leftEyelid; // Reference for animations
                    
                    const rightEyelid = new THREE.Mesh(eyelidGeom, eyelidMat);
                    rightEyelid.position.set(-0.2, 0.07, 0.43);
                    rightEyelid.rotation.x = Math.PI / 2;
                    headGroup.add(rightEyelid);
                    character.rightEyelid = rightEyelid; // Reference for animations
                    
                    // Mouth with more detail - make it curved
                    const mouthGeom = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
                    const mouthMat = new THREE.MeshBasicMaterial({ color: 0x662222 });
                    const mouth = new THREE.Mesh(mouthGeom, mouthMat);
                    mouth.position.set(0, -0.17, 0.47);
                    mouth.rotation.x = -Math.PI / 2;
                    mouth.scale.x = 0.8;
                    headGroup.add(mouth);
                    character.mouth = mouth; // Reference for animations
                    
                    // Nose with better shape
                    const noseGeom = new THREE.ConeGeometry(0.08, 0.12, 6);
                    const noseMat = new THREE.MeshStandardMaterial({ color: 0xdd9977 });
                    const nose = new THREE.Mesh(noseGeom, noseMat);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.set(0, -0.05, 0.5);
                    headGroup.add(nose);
                    
                    // Ears - more rounded
                    const earGeom = new THREE.SphereGeometry(0.12, 8, 8, Math.PI/2, Math.PI, 0, Math.PI);
                    const earMat = new THREE.MeshStandardMaterial({ color: 0xd3a286, roughness: 0.5 });
                    
                    const leftEar = new THREE.Mesh(earGeom, earMat);
                    leftEar.position.set(0.44, 0, 0);
                    leftEar.rotation.y = -Math.PI/2;
                    headGroup.add(leftEar);
                    
                    const rightEar = new THREE.Mesh(earGeom, earMat);
                    rightEar.position.set(-0.44, 0, 0);
                    rightEar.rotation.y = Math.PI/2;
                    headGroup.add(rightEar);
                    
                    // Arms with joints and better shapes
                    // Shoulder joints as spheres
                    const shoulderJointGeom = new THREE.SphereGeometry(0.22, 12, 12);
                    const jointMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    
                    const leftShoulderJoint = new THREE.Mesh(shoulderJointGeom, jointMat);
                    leftShoulderJoint.position.set(0.7, 2.0, 0);
                    leftShoulderJoint.castShadow = true;
                    character.add(leftShoulderJoint);
                    
                    const rightShoulderJoint = new THREE.Mesh(shoulderJointGeom, jointMat);
                    rightShoulderJoint.position.set(-0.7, 2.0, 0);
                    rightShoulderJoint.castShadow = true;
                    character.add(rightShoulderJoint);
                    
                    // Upper arms as cylinders
                    const upperArmGeom = new THREE.CylinderGeometry(0.18, 0.17, 0.7, 8);
                    const armMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    
                    // Create groups for arm rotation
                    const leftArmGroup = new THREE.Group();
                    leftArmGroup.position.set(0.7, 2.0, 0);
                    character.add(leftArmGroup);
                    character.leftArmGroup = leftArmGroup;
                    
                    const leftUpperArm = new THREE.Mesh(upperArmGeom, armMat);
                    leftUpperArm.position.y = -0.35;
                    leftUpperArm.castShadow = true;
                    leftArmGroup.add(leftUpperArm);
                    
                    const rightArmGroup = new THREE.Group();
                    rightArmGroup.position.set(-0.7, 2.0, 0);
                    character.add(rightArmGroup);
                    character.rightArmGroup = rightArmGroup;
                    
                    const rightUpperArm = new THREE.Mesh(upperArmGeom, armMat);
                    rightUpperArm.position.y = -0.35;
                    rightUpperArm.castShadow = true;
                    rightArmGroup.add(rightUpperArm);
                    
                    // Elbow joints
                    const elbowJointGeom = new THREE.SphereGeometry(0.17, 12, 12);
                    
                    const leftElbowJoint = new THREE.Mesh(elbowJointGeom, jointMat);
                    leftElbowJoint.position.y = -0.7;
                    leftElbowJoint.castShadow = true;
                    leftArmGroup.add(leftElbowJoint);
                    
                    const rightElbowJoint = new THREE.Mesh(elbowJointGeom, jointMat);
                    rightElbowJoint.position.y = -0.7;
                    rightElbowJoint.castShadow = true;
                    rightArmGroup.add(rightElbowJoint);
                    
                    // Forearm groups
                    const leftForearmGroup = new THREE.Group();
                    leftForearmGroup.position.set(0, -0.7, 0);
                    leftArmGroup.add(leftForearmGroup);
                    character.leftForearmGroup = leftForearmGroup;
                    
                    const rightForearmGroup = new THREE.Group();
                    rightForearmGroup.position.set(0, -0.7, 0);
                    rightArmGroup.add(rightForearmGroup);
                    character.rightForearmGroup = rightForearmGroup;
                    
                    // Forearms
                    const forearmGeom = new THREE.CylinderGeometry(0.16, 0.15, 0.65, 8);
                    
                    const leftForearm = new THREE.Mesh(forearmGeom, armMat);
                    leftForearm.position.y = -0.325;
                    leftForearm.castShadow = true;
                    leftForearmGroup.add(leftForearm);
                    
                    const rightForearm = new THREE.Mesh(forearmGeom, armMat);
                    rightForearm.position.y = -0.325;
                    rightForearm.castShadow = true;
                    rightForearmGroup.add(rightForearm);
                    
                    // Hands - more rounded
                    const handGeom = new THREE.SphereGeometry(0.15, 12, 12);
                    const handMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 });
                    
                    const leftHand = new THREE.Mesh(handGeom, handMat);
                    leftHand.position.y = -0.65;
                    leftHand.castShadow = true;
                    leftForearmGroup.add(leftHand);
                    
                    const rightHand = new THREE.Mesh(handGeom, handMat);
                    rightHand.position.y = -0.65;
                    rightHand.castShadow = true;
                    rightForearmGroup.add(rightHand);
                    
                    // Legs with joints
                    // Hip joints
                    const hipJointGeom = new THREE.SphereGeometry(0.22, 12, 12);
                    const legJointMat = new THREE.MeshStandardMaterial({ color: 0x222266, roughness: 0.7 });
                    
                    const leftHipJoint = new THREE.Mesh(hipJointGeom, legJointMat);
                    leftHipJoint.position.set(0.3, 0.4, 0);
                    leftHipJoint.castShadow = true;
                    character.add(leftHipJoint);
                    
                    const rightHipJoint = new THREE.Mesh(hipJointGeom, legJointMat);
                    rightHipJoint.position.set(-0.3, 0.4, 0);
                    rightHipJoint.castShadow = true;
                    character.add(rightHipJoint);
                    
                    // Leg groups for animation
                    const leftLegGroup = new THREE.Group();
                    leftLegGroup.position.set(0.3, 0.4, 0);
                    character.add(leftLegGroup);
                    character.leftLegGroup = leftLegGroup;
                    
                    const rightLegGroup = new THREE.Group();
                    rightLegGroup.position.set(-0.3, 0.4, 0);
                    character.add(rightLegGroup);
                    character.rightLegGroup = rightLegGroup;
                    
                    // Upper legs (thighs)
                    const thighGeom = new THREE.CylinderGeometry(0.18, 0.17, 0.7, 8);
                    const legMat = new THREE.MeshStandardMaterial({ color: 0x222266, roughness: 0.7 });
                    
                    const leftThigh = new THREE.Mesh(thighGeom, legMat);
                    leftThigh.position.y = -0.35;
                    leftThigh.castShadow = true;
                    leftLegGroup.add(leftThigh);
                    
                    const rightThigh = new THREE.Mesh(thighGeom, legMat);
                    rightThigh.position.y = -0.35;
                    rightThigh.castShadow = true;
                    rightLegGroup.add(rightThigh);
                    
                    // Knee joints
                    const kneeJointGeom = new THREE.SphereGeometry(0.17, 12, 12);
                    
                    const leftKneeJoint = new THREE.Mesh(kneeJointGeom, legJointMat);
                    leftKneeJoint.position.y = -0.7;
                    leftKneeJoint.castShadow = true;
                    leftLegGroup.add(leftKneeJoint);
                    
                    const rightKneeJoint = new THREE.Mesh(kneeJointGeom, legJointMat);
                    rightKneeJoint.position.y = -0.7;
                    rightKneeJoint.castShadow = true;
                    rightLegGroup.add(rightKneeJoint);
                    
                    // Lower leg groups
                    const leftCalfGroup = new THREE.Group();
                    leftCalfGroup.position.set(0, -0.7, 0);
                    leftLegGroup.add(leftCalfGroup);
                    character.leftCalfGroup = leftCalfGroup;
                    
                    const rightCalfGroup = new THREE.Group();
                    rightCalfGroup.position.set(0, -0.7, 0);
                    rightLegGroup.add(rightCalfGroup);
                    character.rightCalfGroup = rightCalfGroup;
                    
                    // Lower legs (calves)
                    const calfGeom = new THREE.CylinderGeometry(0.16, 0.15, 0.65, 8);
                    
                    const leftCalf = new THREE.Mesh(calfGeom, legMat);
                    leftCalf.position.y = -0.325;
                    leftCalf.castShadow = true;
                    leftCalfGroup.add(leftCalf);
                    
                    const rightCalf = new THREE.Mesh(calfGeom, legMat);
                    rightCalf.position.y = -0.325;
                    rightCalf.castShadow = true;
                    rightCalfGroup.add(rightCalf);
                    
                    // Ankle joints
                    const ankleJointGeom = new THREE.SphereGeometry(0.15, 12, 12);
                    
                    const leftAnkle = new THREE.Mesh(ankleJointGeom, legJointMat);
                    leftAnkle.position.y = -0.65;
                    leftAnkle.castShadow = true;
                    leftCalfGroup.add(leftAnkle);
                    
                    const rightAnkle = new THREE.Mesh(ankleJointGeom, legJointMat);
                    rightAnkle.position.y = -0.65;
                    rightAnkle.castShadow = true;
                    rightCalfGroup.add(rightAnkle);
                    
                    // Feet
                    const footGeom = new THREE.BoxGeometry(0.35, 0.15, 0.5);
                    footGeom.translate(0, 0, 0.1); // Move origin to heel
                    const footMat = new THREE.MeshStandardMaterial({ color: 0x554433, roughness: 0.8 });
                    
                    const leftFoot = new THREE.Mesh(footGeom, footMat);
                    leftFoot.position.y = -0.72;
                    leftFoot.castShadow = true;
                    leftCalfGroup.add(leftFoot);
                    
                    const rightFoot = new THREE.Mesh(footGeom, footMat);
                    rightFoot.position.y = -0.72;
                    rightFoot.castShadow = true;
                    rightCalfGroup.add(rightFoot);
                    
                    return character;
                }
                
                function setupControls() {
                    // Handle pointer lock
                    document.addEventListener('click', function(event) {
                        // Only lock pointer in shiftlock mode or when right mouse is not pressed
                        if (state.cameraMode === 'shiftlock' && event.button === 0) {
                            document.body.requestPointerLock = document.body.requestPointerLock || 
                                                            document.body.mozRequestPointerLock ||
                                                            document.body.webkitRequestPointerLock;
                            document.body.requestPointerLock();
                        }
                    });
                    
                    document.addEventListener('pointerlockchange', lockChangeHandler, false);
                    document.addEventListener('mozpointerlockchange', lockChangeHandler, false);
                    document.addEventListener('webkitpointerlockchange', lockChangeHandler, false);
                    
                    // Track mouse movement for free camera mode
                    document.addEventListener('mousemove', function(event) {
                        // Handle right-click drag in free mode
                        if (state.cameraMode === 'free' && state.rightMouseDown) {
                            const deltaX = event.clientX - state.mousePosition.x;
                            const deltaY = event.clientY - state.mousePosition.y;
                            
                            // Update camera rotation
                            state.cameraRotation.y -= deltaX * 0.01;
                            state.cameraRotation.x -= deltaY * 0.01;
                            
                            // Clamp vertical rotation
                            state.cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, state.cameraRotation.x));
                            
                            // Reset mouse position to its original point when right-click started
                            if (document.pointerLockElement !== document.body) {
                                window.scrollTo(window.scrollX, window.scrollY); // Prevent page scrolling
                            }
                        }
                    });
                    
                    // Prevent default drag behavior
                    document.addEventListener('dragstart', function(event) {
                        if (state.rightMouseDown) {
                            event.preventDefault();
                        }
                    });
                    
                    // Handle right mouse button for orbital camera
                    document.addEventListener('mousedown', function(event) {
                        if (event.button === 2) { // Right mouse button
                            state.rightMouseDown = true;
                            state.mousePosition.x = event.clientX;
                            state.mousePosition.y = event.clientY;
                            
                            // Request pointer lock for right-click camera control in free mode
                            if (state.cameraMode === 'free') {
                                document.body.requestPointerLock = document.body.requestPointerLock || 
                                                                document.body.mozRequestPointerLock ||
                                                                document.body.webkitRequestPointerLock;
                                document.body.requestPointerLock();
                            }
                            
                            event.preventDefault();
                        }
                    });
                    
                    document.addEventListener('mouseup', function(event) {
                        if (event.button === 2) { // Right mouse button
                            state.rightMouseDown = false;
                            
                            // Exit pointer lock when releasing right-click in free mode
                            if (state.cameraMode === 'free' && document.pointerLockElement === document.body) {
                                document.exitPointerLock();
                            }
                            
                            event.preventDefault();
                        }
                    });
                    
                    // Prevent context menu on right-click
                    document.addEventListener('contextmenu', function(event) {
                        event.preventDefault();
                    });
                    
                    function lockChangeHandler() {
                        if (document.pointerLockElement === document.body || 
                            document.mozPointerLockElement === document.body ||
                            document.webkitPointerLockElement === document.body) {
                            blocker.style.display = 'none';
                            document.addEventListener('mousemove', handleMouseMove, false);
                        } else {
                            // Only show blocker in shiftlock mode
                            if (state.cameraMode === 'shiftlock') {
                                blocker.style.display = 'flex';
                            } else {
                                blocker.style.display = 'none';
                            }
                            document.removeEventListener('mousemove', handleMouseMove, false);
                        }
                    }
                    
                    function handleMouseMove(event) {
                        // Only process in shiftlock mode or when right mouse is down in free mode
                        if (document.pointerLockElement === document.body || 
                            document.mozPointerLockElement === document.body ||
                            document.webkitPointerLockElement === document.body) {
                            
                            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                            
                            if (state.cameraMode === 'shiftlock' || (state.cameraMode === 'free' && state.rightMouseDown)) {
                                // Update camera rotation
                                state.cameraRotation.y -= movementX * 0.01;
                                state.cameraRotation.x -= movementY * 0.01;
                                
                                // Clamp vertical rotation to prevent flipping
                                state.cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, state.cameraRotation.x));
                                
                                // Update player rotation to match camera horizontal rotation in shiftlock mode
                                if (state.cameraMode === 'shiftlock') {
                                    player.rotation.y = state.cameraRotation.y;
                                }
                            }
                        }
                    }
                    
                    // Update the blocker text based on camera mode
                    function updateBlockerText() {
                        if (state.cameraMode === 'shiftlock') {
                            blocker.innerHTML = '<div style="color:white;font-size:24px;">Click to play (Shift-Lock Mode)</div>';
                        } else {
                            blocker.style.display = 'none';
                        }
                    }
                    
                    // Handle shift key to toggle camera modes
                    document.addEventListener('keydown', function(event) {
                        if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                            // Toggle camera mode
                            state.cameraMode = state.cameraMode === 'shiftlock' ? 'free' : 'shiftlock';
                            
                            // Update debug info
                            debugElement.textContent = `Camera Mode: ${state.cameraMode}`;
                            
                            // Request pointer lock automatically when shifting to shiftlock mode
                            if (state.cameraMode === 'shiftlock') {
                                document.body.requestPointerLock = document.body.requestPointerLock || 
                                                               document.body.mozRequestPointerLock ||
                                                               document.body.webkitRequestPointerLock;
                                document.body.requestPointerLock();
                            }
                            // If switching to free mode, exit pointer lock
                            else if (document.pointerLockElement === document.body) {
                                document.exitPointerLock();
                            }
                            
                            // Update blocker text
                            updateBlockerText();
                        }
                    });
                    
                    // Initialize blocker text
                    updateBlockerText();
                }
                
                // Set up key controls
                document.addEventListener('keydown', function(event) {
                    switch (event.code) {
                        case 'KeyW':
                            moveForward = true;
                            break;
                        case 'KeyA':
                            moveLeft = true;
                            break;
                        case 'KeyS':
                            moveBackward = true;
                            break;
                        case 'KeyD':
                            moveRight = true;
                            break;
                        case 'KeyE':
                            // Toggle inventory when E is pressed
                            console.log("E key pressed - toggling inventory");
                            toggleInventory();
                            break;
                        case 'Space':
                            if (canJump) {
                                state.playerVelocity.y = state.jumpForce;
                                canJump = false;
                                // Explicitly reset jump animation state to ensure it starts fresh each time
                                state.jumpPhase = "startup";
                                state.jumpTime = 0;
                                state.landingComplete = false; // Track if landing animation has completed
                            }
                            break;
                    }
                });
                
                document.addEventListener('keyup', function(event) {
                    switch (event.code) {
                        case 'KeyW':
                            moveForward = false;
                            break;
                        case 'KeyA':
                            moveLeft = false;
                            break;
                        case 'KeyS':
                            moveBackward = false;
                            break;
                        case 'KeyD':
                            moveRight = false;
                            break;
                    }
                });
                
                // Animation functions for the character
                function animateCharacter(delta) {
                    // Determine animation state
                    if (!canJump) {
                        state.animationState = 'jumping';
                    } else if (!state.landingComplete && state.jumpPhase === "landing") {
                        // Keep in jumping state until landing animation completes
                        state.animationState = 'jumping';
                    } else if (moveForward || moveBackward || moveLeft || moveRight) {
                        state.animationState = 'walking';
                    } else {
                        state.animationState = 'idle';
                    }
                    
                    // Reset all animations first
                    resetCharacterPose();
                    
                    // Apply animation based on state
                    if (state.animationState === 'idle') {
                        idleAnimation(delta);
                    } else if (state.animationState === 'walking') {
                        walkingAnimation(delta);
                    } else if (state.animationState === 'jumping') {
                        jumpingAnimation(delta);
                    }
                }
                
                // Reset animation state functions for the original model
                function resetCharacterPose() {
                    // Reset arm rotations
                    if (player.leftArmGroup) {
                        player.leftArmGroup.rotation.x = 0;
                        player.leftArmGroup.rotation.z = 0;
                    }
                    if (player.rightArmGroup) {
                        player.rightArmGroup.rotation.x = 0;
                        player.rightArmGroup.rotation.z = 0;
                    }
                    if (player.leftForearmGroup) player.leftForearmGroup.rotation.x = 0;
                    if (player.rightForearmGroup) player.rightForearmGroup.rotation.x = 0;
                    
                    // Reset leg rotations
                    if (player.leftLegGroup) {
                        player.leftLegGroup.rotation.x = 0;
                        player.leftLegGroup.rotation.z = 0;
                    }
                    if (player.rightLegGroup) {
                        player.rightLegGroup.rotation.x = 0;
                        player.rightLegGroup.rotation.z = 0;
                    }
                    if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = 0;
                    if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = 0;
                    
                    // Reset torso parts
                    if (player.torso) {
                        player.torso.rotation.x = 0;
                        player.torso.rotation.y = 0;
                    }
                    if (player.shoulders) player.shoulders.rotation.y = 0;
                    
                    // Reset head and face
                    if (player.headGroup) {
                        player.headGroup.rotation.x = 0;
                        player.headGroup.rotation.y = 0;
                        player.headGroup.position.y = 2.5; // Reset head position
                    }
                    
                    // Reset facial features
                    if (player.leftEye) player.leftEye.scale.set(1, 1, 1);
                    if (player.rightEye) player.rightEye.scale.set(1, 1, 1);
                    if (player.mouth) player.mouth.scale.set(1, 1, 1);
                    if (player.leftEyelid) player.leftEyelid.scale.y = 1;
                    if (player.rightEyelid) player.rightEyelid.scale.y = 1;
                }
                
                function idleAnimation(delta) {
                    // Track animation time
                    state.idleTime = (state.idleTime || 0) + delta;
                    
                    // Subtle breathing motion with enhanced movement
                    const breathAmount = Math.sin(Date.now() * 0.001) * 0.04;
                    
                    // Subtle shoulder movement
                    if (player.leftArmGroup) {
                        player.leftArmGroup.rotation.x = breathAmount * 0.7;
                        player.leftArmGroup.rotation.z = breathAmount * 0.2;
                    }
                    if (player.rightArmGroup) {
                        player.rightArmGroup.rotation.x = breathAmount * 0.7;
                        player.rightArmGroup.rotation.z = -breathAmount * 0.2;
                    }
                    
                    // Occasional head movements to look around
                    if (state.idleTime > state.lastHeadMove + 3 + Math.random() * 5) {
                        state.headTargetRotation = {
                            x: (Math.random() - 0.5) * 0.5,
                            y: (Math.random() - 0.5) * 0.8
                        };
                        state.lastHeadMove = state.idleTime;
                        state.headMoveDuration = 0.5 + Math.random() * 0.5;
                        state.headMoveStart = state.idleTime;
                    }
                    
                    // Smooth head movement
                    if (state.headTargetRotation && state.idleTime < state.headMoveStart + state.headMoveDuration) {
                        const progress = (state.idleTime - state.headMoveStart) / state.headMoveDuration;
                        const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                        
                        if (player.headGroup) {
                            player.headGroup.rotation.x = breathAmount * 0.3 + state.headTargetRotation.x * easedProgress;
                            player.headGroup.rotation.y = state.headTargetRotation.y * easedProgress;
                        }
                    } else if (player.headGroup) {
                        // Return to neutral with breathing
                        player.headGroup.rotation.x = breathAmount * 0.3;
                        player.headGroup.rotation.y = 0;
                    }
                    
                    // Subtle weight shifting in legs
                    if (player.leftLegGroup) player.leftLegGroup.rotation.z = -Math.abs(breathAmount * 0.1);
                    if (player.rightLegGroup) player.rightLegGroup.rotation.z = Math.abs(breathAmount * 0.1);
                    
                    // Occasional blink with better timing
                    if (Math.random() < 0.007 && player.leftEyelid && player.rightEyelid) {
                        player.leftEyelid.scale.y = 0.2;
                        player.rightEyelid.scale.y = 0.2;
                        setTimeout(() => {
                            if (player.leftEyelid) player.leftEyelid.scale.y = 1;
                            if (player.rightEyelid) player.rightEyelid.scale.y = 1;
                        }, 150);
                    }
                }
                
                function walkingAnimation(delta) {
                    state.timeSinceLastStep += delta;
                    const walkCycle = Math.sin(state.timeSinceLastStep * 10);
                    const swingAmount = walkCycle * 0.8; // Increased from 0.5 to 0.8 for more noticeable movement
                    
                    // Arms swing opposite to legs - increased range
                    if (player.leftArmGroup) player.leftArmGroup.rotation.x = -swingAmount * 1.2;
                    if (player.rightArmGroup) player.rightArmGroup.rotation.x = swingAmount * 1.2;
                    
                    // Add subtle arm rotation around z-axis for more natural movement
                    if (player.leftArmGroup) player.leftArmGroup.rotation.z = Math.abs(swingAmount * 0.2);
                    if (player.rightArmGroup) player.rightArmGroup.rotation.z = -Math.abs(swingAmount * 0.2);
                    
                    // Add forearm movement with increased bend
                    if (player.leftForearmGroup) player.leftForearmGroup.rotation.x = -Math.abs(swingAmount * 0.8);
                    if (player.rightForearmGroup) player.rightForearmGroup.rotation.x = -Math.abs(swingAmount * 0.8);
                    
                    // Legs movement with increased range
                    if (player.leftLegGroup) player.leftLegGroup.rotation.x = swingAmount * 1.2;
                    if (player.rightLegGroup) player.rightLegGroup.rotation.x = -swingAmount * 1.2;
                    
                    // Add knee bend during walking - increased bend
                    if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = Math.abs(swingAmount * 1.0);
                    if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = Math.abs(swingAmount * 1.0);
                    
                    // Add torso twist for more natural walking
                    if (player.torso) {
                        player.torso.rotation.y = walkCycle * 0.1;
                    }
                    
                    // Add shoulder twist opposite to torso
                    if (player.shoulders) {
                        player.shoulders.rotation.y = -walkCycle * 0.15;
                    }
                    
                    // Add enhanced head bob with slight forward tilt using headGroup
                    if (player.headGroup) {
                        player.headGroup.position.y = 2.5 + Math.abs(walkCycle) * 0.08; // Apply bob to the group position
                        player.headGroup.rotation.x = Math.abs(walkCycle) * 0.15;
                        player.headGroup.rotation.y = -walkCycle * 0.1; // Head turns slightly opposite to torso
                    }
                    
                    // Add torso lean with more pronounced forward tilt when moving forward
                    const torsoLean = Math.abs(walkCycle) * 0.1;
                    if (moveForward) {
                        if (player.torso) player.torso.rotation.x = torsoLean;
                        if (player.headGroup) player.headGroup.rotation.x = torsoLean * 1.5;
                    }
                    
                    // Add slight bouncing effect to whole character
                    player.position.y = 1 + Math.abs(Math.sin(state.timeSinceLastStep * 20)) * 0.05;
                }
                
                function jumpingAnimation(delta) {
                    // Track jump phase
                    if (!state.jumpPhase) {
                        state.jumpPhase = "startup";
                        state.jumpTime = 0;
                    }
                    
                    state.jumpTime += delta;
                    
                    // Handle different jump phases with sequential animation
                    if (state.jumpPhase === "startup" && state.jumpTime < 0.15) {
                        // Initial crouch and arm preparation
                        const prepProgress = state.jumpTime / 0.15;
                        // Use easing function for smoother startup
                        const easeInProgress = prepProgress * prepProgress;
                        
                        // Crouch with smooth easing
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = 0.4 * easeInProgress;
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = 0.4 * easeInProgress;
                        
                        // Knees bent more with smooth easing
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = 0.6 * easeInProgress;
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = 0.6 * easeInProgress;
                        
                        // Arms start moving back and slightly outward
                        if (player.leftArmGroup) {
                            player.leftArmGroup.rotation.x = 0.3 * easeInProgress;
                            player.leftArmGroup.rotation.z = 0.1 * easeInProgress; // Move arm outward
                        }
                        if (player.rightArmGroup) {
                            player.rightArmGroup.rotation.x = 0.3 * easeInProgress;
                            player.rightArmGroup.rotation.z = -0.1 * easeInProgress; // Move arm outward
                        }
                    } 
                    else if (state.jumpPhase === "startup" && state.jumpTime >= 0.15) {
                        // Transition to upward phase
                        state.jumpPhase = "upward";
                        state.jumpTime = 0;
                    }
                    else if (state.jumpPhase === "upward" && state.jumpTime < 0.25) {
                        // Fast upward movement - extending legs, raising arms
                        const upProgress = state.jumpTime / 0.25;
                        const easeOut = 1 - Math.pow(1 - upProgress, 2); // Ease out
                        
                        // Legs straightening
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = 0.4 * (1 - easeOut);
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = 0.4 * (1 - easeOut);
                        
                        // Knees extending
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = 0.6 * (1 - easeOut);
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = 0.6 * (1 - easeOut);
                        
                        // Arms coming forward, up, and outward (higher and more spread than before)
                        if (player.leftArmGroup) {
                            player.leftArmGroup.rotation.x = 0.3 * (1 - easeOut) - 1.7 * easeOut; // Higher above head
                            player.leftArmGroup.rotation.z = 0.1 * (1 - easeOut) + 0.3 * easeOut; // More outward from body
                        }
                        if (player.rightArmGroup) {
                            player.rightArmGroup.rotation.x = 0.3 * (1 - easeOut) - 1.7 * easeOut; // Higher above head
                            player.rightArmGroup.rotation.z = -0.1 * (1 - easeOut) - 0.3 * easeOut; // More outward from body
                        }
                        
                        // Forearms bent for a more dynamic pose
                        if (player.leftForearmGroup) player.leftForearmGroup.rotation.x = -0.4 * easeOut;
                        if (player.rightForearmGroup) player.rightForearmGroup.rotation.x = -0.4 * easeOut;
                        
                        // Face expression - wider eyes, open mouth
                        if (player.leftEye) player.leftEye.scale.y = 1 + 0.3 * easeOut;
                        if (player.rightEye) player.rightEye.scale.y = 1 + 0.3 * easeOut;
                        if (player.mouth) player.mouth.scale.y = 1 + 1.5 * easeOut;
                    }
                    else if (state.jumpPhase === "upward" && state.jumpTime >= 0.25) {
                        // Transition to mid-air phase
                        state.jumpPhase = "midair";
                        state.midairStartTime = Date.now(); // Track when we entered midair for the wobble
                    }
                    else if (state.jumpPhase === "midair") {
                        // Calculate a smoother wobble motion that varies over time
                        const wobbleTime = (Date.now() - (state.midairStartTime || Date.now())) / 1000;
                        const airWobble = Math.sin(wobbleTime * 5) * 0.05;
                        
                        // Arms up above head, out to sides, and slightly waving
                        if (player.leftArmGroup) {
                            player.leftArmGroup.rotation.x = -1.7 + airWobble * 0.2; // Higher position
                            player.leftArmGroup.rotation.z = 0.3 + airWobble; // Spread out from torso
                        }
                        if (player.rightArmGroup) {
                            player.rightArmGroup.rotation.x = -1.7 - airWobble * 0.2; // Higher position
                            player.rightArmGroup.rotation.z = -0.3 - airWobble; // Spread out from torso
                        }
                        
                        // Forearms bent at a natural angle
                        if (player.leftForearmGroup) player.leftForearmGroup.rotation.x = -0.5 + airWobble * 0.3;
                        if (player.rightForearmGroup) player.rightForearmGroup.rotation.x = -0.5 - airWobble * 0.3;
                        
                        // Legs slightly spread and bent with subtle variation
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = 0.2 - airWobble * 0.7;
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = 0.2 + airWobble * 0.7;
                        
                        // Knees bent
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = 0.5 + airWobble * 0.1;
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = 0.5 - airWobble * 0.1;
                        
                        // Subtle torso rotation for more life-like motion
                        if (player.torso) {
                            player.torso.rotation.y = airWobble * 0.1;
                            player.torso.rotation.x = 0.1 + airWobble * 0.05;
                        }
                        
                        // Keep head straight instead of tilting down - REMOVED head tilting down
                        // Face expressions remain
                        if (player.leftEye) player.leftEye.scale.y = 1.3;
                        if (player.rightEye) player.rightEye.scale.y = 1.3;
                        if (player.mouth) player.mouth.scale.y = 2.5;
                    }
                    else if (state.jumpPhase === "landing" && state.jumpTime < 0.8) {
                        // Extended landing animation duration (from 0.5 to 0.8) for smoother transition
                        const landProgress = state.jumpTime / 0.8;
                        
                        // Use a custom easing function for more natural lowering motion
                        // Start fast, then slow down toward the end
                        const easeOutQuart = 1 - Math.pow(1 - landProgress, 4);
                        
                        // Arms coming down from above head with natural arc motion
                        if (player.leftArmGroup) {
                            // Multi-phase arm animation for more natural movement
                            if (landProgress < 0.6) {
                                // First phase: arms come down from above head (0-60% of animation)
                                const armPhaseDown = Math.min(1, landProgress / 0.6);
                                const armEasingDown = 1 - Math.pow(1 - armPhaseDown, 3); // Custom easing for arms
                                
                                // X rotation (arms lower from up to down with pendulum motion)
                                const pendulumSwing = Math.sin(armPhaseDown * Math.PI) * 0.3; // Swing effect
                                player.leftArmGroup.rotation.x = -1.7 * (1 - armEasingDown) + pendulumSwing;
                                
                                // Z rotation (arms move from out to in)
                                player.leftArmGroup.rotation.z = 0.3 * (1 - armEasingDown * 0.8);
                            } 
                            else {
                                // Second phase: arms settle into final position (60-100% of animation)
                                const armPhaseSettle = (landProgress - 0.6) / 0.4;
                                const armEasingSettle = 1 - Math.pow(1 - armPhaseSettle, 2);
                                
                                // Gentle dampening oscillation as arms reach rest position
                                const dampedOscillation = Math.sin(armPhaseSettle * Math.PI * 1.5) * 0.15 * (1 - armPhaseSettle);
                                player.leftArmGroup.rotation.x = dampedOscillation;
                                
                                // Z rotation continues to settle
                                player.leftArmGroup.rotation.z = 0.3 * (1 - 0.8) * (1 - armEasingSettle) + 
                                                               breathingEffect(dampedOscillation) * 0.1;
                            }
                        }
                        
                        if (player.rightArmGroup) {
                            // Mirror the left arm movements
                            if (landProgress < 0.6) {
                                // First phase
                                const armPhaseDown = Math.min(1, landProgress / 0.6);
                                const armEasingDown = 1 - Math.pow(1 - armPhaseDown, 3);
                                
                                const pendulumSwing = Math.sin(armPhaseDown * Math.PI) * 0.3;
                                player.rightArmGroup.rotation.x = -1.7 * (1 - armEasingDown) + pendulumSwing;
                                player.rightArmGroup.rotation.z = -0.3 * (1 - armEasingDown * 0.8);
                            } 
                            else {
                                // Second phase
                                const armPhaseSettle = (landProgress - 0.6) / 0.4;
                                const armEasingSettle = 1 - Math.pow(1 - armPhaseSettle, 2);
                                
                                const dampedOscillation = Math.sin(armPhaseSettle * Math.PI * 1.5) * 0.15 * (1 - armPhaseSettle);
                                player.rightArmGroup.rotation.x = dampedOscillation;
                                player.rightArmGroup.rotation.z = -0.3 * (1 - 0.8) * (1 - armEasingSettle) - 
                                                                breathingEffect(dampedOscillation) * 0.1;
                            }
                        }
                        
                        // Forearms relaxing with slight lag behind upper arms
                        if (player.leftForearmGroup) {
                            if (landProgress < 0.65) {
                                const forearmPhase = Math.max(0, Math.min(1, (landProgress - 0.05) / 0.6));
                                const forearmEase = 1 - Math.pow(1 - forearmPhase, 2);
                                player.leftForearmGroup.rotation.x = -0.5 * (1 - forearmEase);
                            } else {
                                // Add slight bend at the end for natural rest position
                                const finalBendPhase = (landProgress - 0.65) / 0.35;
                                const finalBendEase = 1 - Math.pow(1 - finalBendPhase, 2);
                                const restingBend = -0.1;
                                player.leftForearmGroup.rotation.x = restingBend * finalBendEase;
                            }
                        }
                        
                        if (player.rightForearmGroup) {
                            if (landProgress < 0.65) {
                                const forearmPhase = Math.max(0, Math.min(1, (landProgress - 0.05) / 0.6));
                                const forearmEase = 1 - Math.pow(1 - forearmPhase, 2);
                                player.rightForearmGroup.rotation.x = -0.5 * (1 - forearmEase);
                            } else {
                                const finalBendPhase = (landProgress - 0.65) / 0.35;
                                const finalBendEase = 1 - Math.pow(1 - finalBendPhase, 2);
                                const restingBend = -0.1;
                                player.rightForearmGroup.rotation.x = restingBend * finalBendEase;
                            }
                        }
                        
                        // Legs absorbing landing impact - initial bend followed by straightening
                        const kneeAbsorb = landProgress < 0.4 
                            ? Math.sin(landProgress * Math.PI / 0.8) * 0.7 // Rise to peak bend
                            : Math.sin(0.5 * Math.PI + (landProgress - 0.4) * Math.PI / 1.2) * 0.35 * (1 - (landProgress - 0.4) / 0.6); // Fall to straight
                        
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = kneeAbsorb;
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = kneeAbsorb;
                        
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = kneeAbsorb * 1.5;
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = kneeAbsorb * 1.5;
                        
                        // Torso slight forward lean then straightening
                        if (player.torso) {
                            if (landProgress < 0.5) {
                                player.torso.rotation.x = 0.15 * (1 - landProgress / 0.5);
                                player.torso.rotation.y = 0;
                            } else {
                                // Subtle torso balancing adjustment as it reaches equilibrium
                                const balancePhase = (landProgress - 0.5) / 0.5;
                                player.torso.rotation.x = Math.sin(balancePhase * Math.PI) * 0.05 * (1 - balancePhase);
                            }
                        }
                        
                        // Face returning to normal
                        if (player.leftEye) player.leftEye.scale.y = 1 + 0.3 * (1 - easeOutQuart);
                        if (player.rightEye) player.rightEye.scale.y = 1 + 0.3 * (1 - easeOutQuart);
                        if (player.mouth) player.mouth.scale.y = 1 + 1.5 * (1 - easeOutQuart);
                    }
                    
                    // Transition to landing when touching ground
                    if (canJump && state.jumpPhase === "midair") {
                        state.jumpPhase = "landing";
                        state.jumpTime = 0;
                    }
                    // Reset jump animation when landing animation completes
                    else if (canJump && state.jumpPhase === "landing" && state.jumpTime >= 0.8) {
                        state.jumpPhase = null;
                        state.landingComplete = true; // Mark landing as complete to transition to idle
                    }
                    // Reset jump animation when on ground (fallback)
                    else if (canJump && !state.jumpPhase) {
                        state.jumpPhase = null;
                        state.landingComplete = true;
                    }
                }
                
                // Helper function for subtle breathing effect
                function breathingEffect(input) {
                    return Math.sin(Date.now() * 0.001) * Math.max(0.5, Math.abs(input));
                }
                
                // Update 3rd person camera position
                function updateCamera() {
                    // Calculate camera position in orbit around player using spherical coordinates
                    const distance = state.cameraOffset.z;
                    
                    // Calculate position using spherical coordinates
                    const x = distance * Math.sin(state.cameraRotation.y) * Math.cos(state.cameraRotation.x);
                    const y = distance * Math.sin(state.cameraRotation.x);
                    const z = distance * Math.cos(state.cameraRotation.y) * Math.cos(state.cameraRotation.x);
                    
                    // Set camera position relative to player
                    camera.position.x = player.position.x - x;
                    camera.position.y = player.position.y + state.cameraOffset.y + y;
                    camera.position.z = player.position.z - z;
                    
                    // Always look at the player
                    const targetPosition = new THREE.Vector3(
                        player.position.x,
                        player.position.y + 2, // Head height
                        player.position.z
                    );
                    
                    camera.lookAt(targetPosition);
                    
                    // Update player rotation based on camera mode
                    if (state.cameraMode === 'shiftlock') {
                        // In shiftlock mode, player faces camera direction
                        player.rotation.y = state.cameraRotation.y;
                    }
                }
                
                // Game update function
                function update(time, delta) {
                    // Check if game is active (pointer is locked in shiftlock mode or we're in free mode)
                    if ((document.pointerLockElement === document.body || 
                         document.mozPointerLockElement === document.body || 
                         document.webkitPointerLockElement === document.body) || 
                        state.cameraMode === 'free') {
                        
                        // Apply gravity
                        state.playerVelocity.y -= state.gravity;
                        
                        // Calculate movement direction in player's local space
                        let xMove = 0;
                        let zMove = 0;
                        
                        if (moveForward) zMove += state.movementSpeed;
                        if (moveBackward) zMove -= state.movementSpeed;
                        if (moveLeft) xMove -= state.movementSpeed;
                        if (moveRight) xMove += state.movementSpeed;
                        
                        // Store original position for collision detection
                        const originalPosition = {
                            x: player.position.x,
                            z: player.position.z
                        };
                        
                        // Move player based on camera mode
                        if (xMove !== 0 || zMove !== 0) {
                            // Update last input time whenever there's movement
                            state.lastInputTime = time;
                            
                            if (state.cameraMode === 'shiftlock') {
                                // In shiftlock mode, move relative to camera/player direction
                                // Calculate normalized movement vector for consistent speed
                                const moveVector = new THREE.Vector3(xMove, 0, zMove);
                                const inputMagnitude = moveVector.length();
                                if (inputMagnitude > 0) {
                                    moveVector.normalize();
                                    // Use normalized vector and fixed movement speed to ensure consistent speed in all directions
                                    const shiftLockMoveAmount = state.movementSpeed;
                                    xMove = moveVector.x * shiftLockMoveAmount;
                                    zMove = moveVector.z * shiftLockMoveAmount;
                                }
                                
                                player.position.x += Math.sin(player.rotation.y) * zMove;
                                player.position.z += Math.cos(player.rotation.y) * zMove;
                                
                                player.position.x -= Math.cos(player.rotation.y) * xMove;
                                player.position.z += Math.sin(player.rotation.y) * xMove;
                            } else {
                                // In free mode, player always moves relative to its own facing direction
                                
                                // Calculate target rotation based on input direction
                                let targetRotationY = player.rotation.y;
                                
                                // Reset moving direction when input changes
                                if ((moveLeft && state.movingDirection === 'right') || 
                                    (moveRight && state.movingDirection === 'left') ||
                                    (moveForward && state.movingDirection === 'backward') ||
                                    (moveBackward && state.movingDirection === 'forward')) {
                                    state.movingDirection = null;
                                }
                                
                                // Determine movement direction based on camera view
                                let moveDirection = null;
                                if (moveLeft && !moveRight) {
                                    // Left relative to camera
                                    targetRotationY = state.cameraRotation.y + Math.PI/2;
                                    state.movingDirection = 'left';
                                    moveDirection = new THREE.Vector3(
                                        Math.cos(state.cameraRotation.y),
                                        0,
                                        -Math.sin(state.cameraRotation.y)
                                    );
                                } else if (moveRight && !moveLeft) {
                                    // Right relative to camera
                                    targetRotationY = state.cameraRotation.y - Math.PI/2;
                                    state.movingDirection = 'right';
                                    moveDirection = new THREE.Vector3(
                                        -Math.cos(state.cameraRotation.y),
                                        0,
                                        Math.sin(state.cameraRotation.y)
                                    );
                                } else if (moveForward && !moveBackward) {
                                    // Forward in camera direction
                                    targetRotationY = state.cameraRotation.y;
                                    state.movingDirection = 'forward';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y),
                                        0,
                                        Math.cos(state.cameraRotation.y)
                                    );
                                } else if (moveBackward && !moveForward) {
                                    // Backward from camera direction
                                    targetRotationY = state.cameraRotation.y + Math.PI;
                                    state.movingDirection = 'backward';
                                    moveDirection = new THREE.Vector3(
                                        -Math.sin(state.cameraRotation.y),
                                        0,
                                        -Math.cos(state.cameraRotation.y)
                                    );
                                }
                                
                                // Handle diagonal movement with better priority handling
                                if (moveForward && moveLeft && !moveRight && !moveBackward) {
                                    targetRotationY = state.cameraRotation.y + Math.PI/4;
                                    state.movingDirection = 'forwardLeft';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y + Math.PI/4),
                                        0,
                                        Math.cos(state.cameraRotation.y + Math.PI/4)
                                    );
                                } else if (moveForward && moveRight && !moveLeft && !moveBackward) {
                                    targetRotationY = state.cameraRotation.y - Math.PI/4;
                                    state.movingDirection = 'forwardRight';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y - Math.PI/4),
                                        0,
                                        Math.cos(state.cameraRotation.y - Math.PI/4)
                                    );
                                } else if (moveBackward && moveLeft && !moveRight && !moveForward) {
                                    targetRotationY = state.cameraRotation.y + Math.PI*3/4;
                                    state.movingDirection = 'backwardLeft';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y + Math.PI*3/4),
                                        0,
                                        Math.cos(state.cameraRotation.y + Math.PI*3/4)
                                    );
                                } else if (moveBackward && moveRight && !moveLeft && !moveForward) {
                                    targetRotationY = state.cameraRotation.y - Math.PI*3/4;
                                    state.movingDirection = 'backwardRight';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y - Math.PI*3/4),
                                        0,
                                        Math.cos(state.cameraRotation.y - Math.PI*3/4)
                                    );
                                }
                                
                                // Smoothly rotate player to face target direction
                                const turnSpeed = 3.0 * delta; // Reduced from 5.0 to 3.0 for smoother turning
                                const angleDiff = targetRotationY - player.rotation.y;
                                
                                // Normalize angle to [-PI, PI] for shortest rotation path
                                const normalizedAngleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                                
                                // Apply smooth rotation
                                if (Math.abs(normalizedAngleDiff) > 0.01) {
                                    player.rotation.y += normalizedAngleDiff * turnSpeed;
                                }
                                
                                // Move player based on input
                                let moveAmount = 0;
                                const moveVector = new THREE.Vector3(xMove, 0, zMove);
                                const inputMagnitude = moveVector.length();
                                
                                if (inputMagnitude > 0) {
                                    moveAmount = state.movementSpeed;
 
                                    // Move directly in the input direction without waiting for turning
                                    if (moveDirection) {
                                        // Normalize movement direction for consistent speed
                                        moveDirection.normalize();
                                        // Move directly in the input direction without waiting for turning
                                        player.position.x += moveDirection.x * moveAmount;
                                        player.position.z += moveDirection.z * moveAmount;
                                    }
                                }
                            }
                        } else {
                            // Reset moving direction when no movement keys are pressed
                            state.movingDirection = null;
                        }
                        
                        // Check for collisions with objects in the scene
                        if (xMove !== 0 || zMove !== 0) {
                            const isColliding = checkCollision(player);
                            
                            // If collision detected, revert to original position
                            if (isColliding) {
                                player.position.x = originalPosition.x;
                                player.position.z = originalPosition.z;
                            }
                        }
                        
                        // Check if player is stuck and break free if needed
                        checkIfStuck(time, player);
                        
                        // Auto-align camera with character direction after delay
                        if (state.cameraMode === 'free' && !state.rightMouseDown) {
                            const timeSinceLastInput = (time / 1000) - state.lastInputTime;
                            if (timeSinceLastInput > state.autoAlignDelay && !moveForward && !moveBackward && !moveLeft && !moveRight) {
                                // Gradually align camera with character direction
                                const angleDiff = player.rotation.y - state.cameraRotation.y;
                                // Normalize angle to [-PI, PI]
                                const normalizedAngleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                                
                                // Apply smooth rotation at a slower pace for more natural feeling
                                state.cameraRotation.y += normalizedAngleDiff * delta * 0.8;
                            }
                        }
                        
                        // Apply jumping
                        if (state.keysPressed['Space'] && canJump) {
                            state.playerVelocity.y = state.jumpForce;
                            canJump = false;
                            
                            // Reset jump animation
                            state.jumpPhase = 'start';
                            state.jumpTime = 0;
                            state.landingComplete = false;
                        }
                        
                        // Apply vertical movement (jumping/falling)
                        player.position.y += state.playerVelocity.y;
                        
                        // Ground collision
                        if (player.position.y < 1) {
                            player.position.y = 1;
                            state.playerVelocity.y = 0;
                            canJump = true;
                        }
                        
                        // Keep player within bounds
                        const boundary = 250; // Increased to match the larger outside environment
                        if (player.position.x > boundary) player.position.x = boundary;
                        if (player.position.x < -boundary) player.position.x = -boundary;
                        if (player.position.z > boundary) player.position.z = boundary;
                        if (player.position.z < -boundary) player.position.z = -boundary;
                        
                        // Adjust fog density based on player position (inside vs outside)
                        adjustFogBasedOnPosition(player.position);
                        
                        // Update camera position
                        updateCamera();
                        
                        // Animate character
                        animateCharacter(delta);
                        
                        debugElement.textContent = `Position: x=${player.position.x.toFixed(2)}, y=${player.position.y.toFixed(2)}, z=${player.position.z.toFixed(2)}`;
                    }
                }
                
                // Collision detection function
                function checkCollision(player) {
                    // Create raycasters in multiple directions
                    const directions = [
                        new THREE.Vector3(1, 0, 0),   // Right
                        new THREE.Vector3(-1, 0, 0),  // Left
                        new THREE.Vector3(0, 0, 1),   // Forward
                        new THREE.Vector3(0, 0, -1),  // Backward
                        new THREE.Vector3(1, 0, 1).normalize(),   // Forward-Right
                        new THREE.Vector3(-1, 0, 1).normalize(),  // Forward-Left
                        new THREE.Vector3(1, 0, -1).normalize(),  // Backward-Right
                        new THREE.Vector3(-1, 0, -1).normalize(), // Backward-Left
                    ];
                    
                    // Reduced player radius to prevent getting stuck
                    const playerRadius = 0.5; // Reduced from 0.7
                    
                    // Slightly elevated position to avoid ground collision issues
                    const playerPosition = new THREE.Vector3(
                        player.position.x,
                        player.position.y + 1.2, // Slightly higher to avoid false positives
                        player.position.z
                    );
                    
                    // Check for collisions in each direction
                    for (const direction of directions) {
                        const raycaster = new THREE.Raycaster(playerPosition, direction, 0, playerRadius);
                        const intersects = raycaster.intersectObjects(scene.children, true);
                        
                        // Filter out non-collidable objects (like the player itself)
                        const collidableIntersects = intersects.filter(intersection => {
                            // Skip player mesh and non-collidable objects
                            const obj = intersection.object;
                            
                            // Skip if it's part of the player model
                            if (obj === player || (obj.parent && (obj.parent === player || obj.parent.parent === player))) {
                                return false;
                            }
                            
                            // Skip non-collidable transparent objects
                            if (obj.material && obj.material.transparent && obj.material.opacity < 0.3) {
                                return false;
                            }
                            
                            // Check for explicitly marked collidable objects
                            const isCollidable = obj.userData && obj.userData.collidable === true;
                            
                            // Skip objects that are too close to the floor
                            const isFloorLike = intersection.point.y < 0.3;
                            
                            return isCollidable && !isFloorLike;
                        });
                        
                        if (collidableIntersects.length > 0) {
                            // Log collision details
                            const hitObject = collidableIntersects[0].object;
                            if (hitObject && hitObject.userData.debugged !== true) {
                                console.log("Collision with:", hitObject);
                                hitObject.userData.debugged = true; // Only log once per object
                            }
                            return true; // Collision detected
                        }
                    }
                    
                    return false; // No collision
                }

                // Add a break-free function to prevent getting completely stuck
                let stuckCheckTimer = 0;
                let lastPlayerPosition = new THREE.Vector3();
                let stuckTime = 0;
                
                // Add this to the update function to prevent permanent sticking
                function checkIfStuck(time, playerObj) {
                    // Only check every second
                    if (time - stuckCheckTimer < 1000) return false;
                    stuckCheckTimer = time;
                    
                    // Check if position has changed
                    const currentPos = new THREE.Vector3(playerObj.position.x, 0, playerObj.position.z);
                    const distance = currentPos.distanceTo(lastPlayerPosition);
                    
                    // If barely moved for 3 seconds while movement keys are pressed
                    const moveForward = state.keysPressed['KeyW'] || false;
                    const moveBackward = state.keysPressed['KeyS'] || false;
                    const moveLeft = state.keysPressed['KeyA'] || false;
                    const moveRight = state.keysPressed['KeyD'] || false;
                    const tryingToMove = moveForward || moveBackward || moveLeft || moveRight;
                    
                    if (distance < 0.1 && tryingToMove) {
                        stuckTime += 1;
                        if (stuckTime >= 3) {
                            // Break free by moving the player up slightly
                            playerObj.position.y += 0.2;
                            stuckTime = 0;
                            console.log("Breaking free from stuck position");
                            return true;
                        }
                    } else {
                        stuckTime = 0;
                    }
                    
                    // Update last position
                    lastPlayerPosition.copy(currentPos);
                    return false;
                }

                // Animation loop with delta time
                let lastFrameTime = 0;
                function animate(time) {
                    requestAnimationFrame(animate);
                    
                    // Calculate delta time
                    const delta = (time - lastFrameTime) / 1000;
                    lastFrameTime = time;
                    
                    // Animate flickering lights if they exist
                    if (window.flickeringLights) {
                        window.flickeringLights.forEach(light => {
                            const { flickerSpeed, flickerIntensity, baseIntensity, timeOffset } = light.userData;
                            
                            // Create organic flickering pattern
                            const flicker = Math.sin(time * flickerSpeed + timeOffset) * 0.5 + 0.5;
                            const noise = Math.random() * 0.2;
                            
                            light.intensity = baseIntensity * (1 - flickerIntensity * 0.8) + 
                                              flickerIntensity * baseIntensity * (flicker + noise);
                        });
                    }
                    
                    update(time, delta);
                    renderer.render(scene, camera);
                }
                
                animate(0);
                
                debugElement.textContent = "Game running - click to start!";
                
                // Initialize inventory system
                initInventorySystem();
                
                // Interior walls to create rooms
                // Living room wall (separating from dining room)
                const livingRoomWall = createWallSection(
                    20,
                    frontWallHeight,
                    houseDimensions.wallThickness,
                    -5,
                    frontWallHeight / 2,
                    houseDimensions.length / 4,
                    materials.wallInterior
                );
                houseGroup.add(livingRoomWall);
                
                // Doorway in living room wall
                const livingRoomDoorway = createWallSection(
                    4,
                    8,
                    houseDimensions.wallThickness,
                    5,
                    4,
                    houseDimensions.length / 4,
                    materials.wallInterior
                );
                // Remove the doorway (creating a hole in the wall)
                // Instead of adding, we just don't add this mesh
                
                // Kitchen wall (perpendicular to living room wall)
                const kitchenWall = createWallSection(
                    houseDimensions.wallThickness,
                    frontWallHeight,
                    20,
                    5,
                    frontWallHeight / 2,
                    houseDimensions.length / 8,
                    materials.wallInterior
                );
                houseGroup.add(kitchenWall);
                
                // Bedroom divider wall
                const bedroomWall = createWallSection(
                    houseDimensions.wallThickness,
                    frontWallHeight,
                    25,
                    -10,
                    frontWallHeight / 2,
                    -houseDimensions.length / 4,
                    materials.wallInterior
                );
                houseGroup.add(bedroomWall);
                
                // Bathroom wall
                const bathroomWall = createWallSection(
                    15,
                    frontWallHeight,
                    houseDimensions.wallThickness,
                    10,
                    frontWallHeight / 2,
                    -houseDimensions.length / 3,
                    materials.wallInterior
                );
                houseGroup.add(bathroomWall);
                
                // Add furniture to different rooms
                
                // Living Room Furniture
                const livingRoomGroup = new THREE.Group();
                // Moved the entire living room group to ensure it's properly positioned
                livingRoomGroup.position.set(0, 0, 5); // Changed z from 10 to 5
                houseGroup.add(livingRoomGroup);
                
                // Couch
                function createCouch() {
                    const couchGroup = new THREE.Group();
                    
                    // Couch base
                    const couchBase = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 1.5, 3.5),
                        materials.fabric
                    );
                    couchBase.position.set(0, 0.75, 0);
                    couchBase.castShadow = true;
                    couchBase.receiveShadow = true;
                    couchGroup.add(couchBase);
                    
                    // Couch back
                    const couchBack = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 3, 1),
                        materials.fabric
                    );
                    couchBack.position.set(0, 2.25, -1.75);
                    couchBack.castShadow = true;
                    couchBack.receiveShadow = true;
                    couchGroup.add(couchBack);
                    
                    // Couch arms
                    const leftArm = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 2.5, 3.5),
                        materials.fabric
                    );
                    leftArm.position.set(-5.5, 1.25, 0);
                    leftArm.castShadow = true;
                    leftArm.receiveShadow = true;
                    couchGroup.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 2.5, 3.5),
                        materials.fabric
                    );
                    rightArm.position.set(5.5, 1.25, 0);
                    rightArm.castShadow = true;
                    rightArm.receiveShadow = true;
                    couchGroup.add(rightArm);
                    
                    // Cushions
                    for (let i = 0; i < 3; i++) {
                        const cushion = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.7, 3),
                            materials.fabricDark
                        );
                        cushion.position.set(-3.5 + i * 3.5, 1.8, 0);
                        cushion.castShadow = true;
                        cushion.receiveShadow = true;
                        couchGroup.add(cushion);
                    }
                    
                    return couchGroup;
                }
                
                const couch = createCouch();
                // Moved couch to be in a better position
                couch.position.set(-2, 0, 0); // Changed x from -5 to -2
                couch.rotation.y = -Math.PI / 2;
                livingRoomGroup.add(couch);
                
                // Coffee table
                const coffeeTable = new THREE.Group();
                
                // Table top
                const tableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 0.5, 4),
                    materials.woodDark
                );
                tableTop.position.set(0, 1.5, 0);
                tableTop.castShadow = true;
                tableTop.receiveShadow = true;
                coffeeTable.add(tableTop);
                
                // Table legs
                for (let x = -1; x <= 1; x += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        const leg = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 1.5, 0.5),
                            materials.woodDark
                        );
                        leg.position.set(x * 2.5, 0.75, z * 1.5);
                        leg.castShadow = true;
                        leg.receiveShadow = true;
                        coffeeTable.add(leg);
                    }
                }
                
                coffeeTable.position.set(2, 0, 0); // Changed from (0, 0, 5) to (2, 0, 0)
                livingRoomGroup.add(coffeeTable);
                
                // TV Stand with TV
                const tvStand = new THREE.Group();
                
                // Stand base
                const standBase = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 2, 2),
                    materials.woodMedium
                );
                standBase.position.set(0, 1, 0);
                standBase.castShadow = true;
                standBase.receiveShadow = true;
                tvStand.add(standBase);
                
                // TV
                const tv = new THREE.Mesh(
                    new THREE.BoxGeometry(7, 4, 0.5),
                    materials.metal
                );
                tv.position.set(0, 4, 0);
                tv.castShadow = true;
                tv.receiveShadow = true;
                tvStand.add(tv);
                
                // TV screen
                const tvScreen = new THREE.Mesh(
                    new THREE.PlaneGeometry(6.5, 3.6),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                tvScreen.position.set(0, 4, 0.26);
                tvStand.add(tvScreen);
                
                tvStand.position.set(8, 0, 0); // Changed from (10, 0, 5) to (8, 0, 0)
                tvStand.rotation.y = Math.PI / 2;
                livingRoomGroup.add(tvStand);
                
                // Armchair
                function createArmchair() {
                    const chairGroup = new THREE.Group();
                    
                    // Chair base
                    const chairBase = new THREE.Mesh(
                        new THREE.BoxGeometry(3.5, 1.5, 3.5),
                        materials.fabricDark
                    );
                    chairBase.position.set(0, 0.75, 0);
                    chairBase.castShadow = true;
                    chairBase.receiveShadow = true;
                    chairGroup.add(chairBase);
                    
                    // Chair back
                    const chairBack = new THREE.Mesh(
                        new THREE.BoxGeometry(3.5, 3, 1),
                        materials.fabricDark
                    );
                    chairBack.position.set(0, 2.25, -1.75);
                    chairBack.castShadow = true;
                    chairBack.receiveShadow = true;
                    chairGroup.add(chairBack);
                    
                    // Chair arms
                    const leftArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 1.8, 3.5),
                        materials.fabricDark
                    );
                    leftArm.position.set(-1.85, 1.4, 0);
                    leftArm.castShadow = true;
                    leftArm.receiveShadow = true;
                    chairGroup.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 1.8, 3.5),
                        materials.fabricDark
                    );
                    rightArm.position.set(1.85, 1.4, 0);
                    rightArm.castShadow = true;
                    rightArm.receiveShadow = true;
                    chairGroup.add(rightArm);
                    
                    // Cushion
                    const cushion = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.7, 3),
                        materials.fabric
                    );
                    cushion.position.set(0, 1.8, 0);
                    cushion.castShadow = true;
                    cushion.receiveShadow = true;
                    chairGroup.add(cushion);
                    
                    return chairGroup;
                }
                
                const armchair1 = createArmchair();
                armchair1.position.set(2, 0, 8); // Changed from (5, 0, 15) to (2, 0, 8)
                armchair1.rotation.y = -Math.PI / 4;
                livingRoomGroup.add(armchair1);
                
                const armchair2 = createArmchair();
                armchair2.position.set(-2, 0, 8); // Changed from (-5, 0, 15) to (-2, 0, 8)
                armchair2.rotation.y = Math.PI / 4;
                livingRoomGroup.add(armchair2);
                
                // Dining Room and Kitchen
                const diningRoomGroup = new THREE.Group();
                // Adjust position so it's more centered in the dining area and away from walls
                // Moving it a bit toward the center to avoid wall intersections
                diningRoomGroup.position.set(15, 0, 10); // Changed from z=15 to z=10
                houseGroup.add(diningRoomGroup);
                
                // Dining table
                const diningTable = new THREE.Group();
                
                // Table top
                const diningTableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 0.5, 5),
                    materials.woodMedium
                );
                diningTableTop.position.set(0, 3, 0);
                diningTableTop.castShadow = true;
                diningTableTop.receiveShadow = true;
                diningTable.add(diningTableTop);
                
                // Table legs
                for (let x = -1; x <= 1; x += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        const leg = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 3, 8),
                            materials.woodMedium
                        );
                        leg.position.set(x * 3.5, 1.5, z * 2);
                        leg.castShadow = true;
                        leg.receiveShadow = true;
                        diningTable.add(leg);
                    }
                }
                
                diningTable.position.set(0, 0, 0);
                diningRoomGroup.add(diningTable);
                
                // Dining chairs
                function createDiningChair() {
                    const chairGroup = new THREE.Group();
                    
                    // Seat
                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.3, 1.8),
                        materials.woodMedium
                    );
                    seat.position.set(0, 1.8, 0);
                    seat.castShadow = true;
                    seat.receiveShadow = true;
                    chairGroup.add(seat);
                    
                    // Back
                    const back = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 2, 0.3),
                        materials.woodMedium
                    );
                    back.position.set(0, 2.9, -0.9);
                    back.castShadow = true;
                    back.receiveShadow = true;
                    chairGroup.add(back);
                    
                    // Legs
                    for (let x = -0.7; x <= 0.7; x += 1.4) {
                        for (let z = -0.7; z <= 0.7; z += 1.4) {
                            const leg = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.1, 0.1, 1.8, 8),
                                materials.woodMedium
                            );
                            leg.position.set(x, 0.9, z);
                            leg.castShadow = true;
                            leg.receiveShadow = true;
                            chairGroup.add(leg);
                        }
                    }
                    
                    return chairGroup;
                }
                
                // Place chairs around the table
                const chairPositions = [
                    { x: 0, z: -3, rotation: 0 },
                    { x: 0, z: 3, rotation: Math.PI },
                    { x: -4, z: 0, rotation: Math.PI / 2 },
                    { x: 4, z: 0, rotation: -Math.PI / 2 },
                ];
                
                chairPositions.forEach(pos => {
                    const chair = createDiningChair();
                    chair.position.set(pos.x, 0, pos.z);
                    chair.rotation.y = pos.rotation;
                    diningRoomGroup.add(chair);
                });
                
                // Kitchen Area
                const kitchenGroup = new THREE.Group();
                // Moved kitchen closer to center to avoid wall collisions
                kitchenGroup.position.set(12, 0, 0); // Changed from x=15 to x=12
                houseGroup.add(kitchenGroup);
                
                // Kitchen counter (L-shaped)
                const counterMaterial = materials.woodLight;
                const counterTopMaterial = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, roughness: 0.4, metalness: 0.3 });
                
                // Base cabinets - moved slightly so they don't overlap with walls
                const counterBaseGeom = new THREE.BoxGeometry(10, 3, 2); // Reduced width from 12 to 10
                const counterBase = new THREE.Mesh(counterBaseGeom, counterMaterial);
                counterBase.position.set(0, 1.5, -7); // Changed z from -8 to -7
                counterBase.castShadow = true;
                counterBase.receiveShadow = true;
                kitchenGroup.add(counterBase);
                
                const counterBaseL = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 6), // Reduced length from 8 to 6
                    counterMaterial
                );
                counterBaseL.position.set(-5, 1.5, -4); // Changed x from -6 to -5
                counterBaseL.castShadow = true;
                counterBaseL.receiveShadow = true;
                kitchenGroup.add(counterBaseL);
                
                // Counter tops - adjusted to match base cabinet changes
                const counterTop = new THREE.Mesh(
                    new THREE.BoxGeometry(10.4, 0.3, 2.4), // Reduced width from 12.4 to 10.4
                    counterTopMaterial
                );
                counterTop.position.set(0, 3.15, -7); // Changed z from -8 to -7
                counterTop.castShadow = true;
                counterTop.receiveShadow = true;
                kitchenGroup.add(counterTop);
                
                const counterTopL = new THREE.Mesh(
                    new THREE.BoxGeometry(2.4, 0.3, 6), // Reduced length from 8 to 6
                    counterTopMaterial
                );
                counterTopL.position.set(-5, 3.15, -4); // Changed x from -6 to -5
                counterTopL.castShadow = true;
                counterTopL.receiveShadow = true;
                kitchenGroup.add(counterTopL);
                
                // Sink
                const sink = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 1.5),
                    materials.metal
                );
                sink.position.set(3, 3.2, -7); // Changed z from -8 to -7
                kitchenGroup.add(sink);
                
                // Stove
                const stove = new THREE.Group();
                const stoveBase = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.1, 1.8),
                    materials.metal
                );
                stoveBase.position.set(-3, 3.2, -7); // Changed z from -8 to -7
                stove.add(stoveBase);
                
                // Burners
                for (let x = -0.6; x <= 0.6; x += 1.2) {
                    for (let z = -0.5; z <= 0.5; z += 1) {
                        const burner = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16),
                            new THREE.MeshStandardMaterial({ color: 0x333333 })
                        );
                        burner.position.set(x, 0.075, z);
                        burner.rotation.x = Math.PI / 2;
                        stove.add(burner);
                    }
                }
                
                stove.position.set(-3, 3.2, -7); // Changed z from -8 to -7
                kitchenGroup.add(stove);
                
                // Refrigerator
                const fridge = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 7, 2.5), // Reduced depth from 3 to 2.5
                    materials.metal
                );
                fridge.position.set(-5, 3.5, 0); // Changed x from -6 to -5
                fridge.castShadow = true;
                fridge.receiveShadow = true;
                kitchenGroup.add(fridge);
                
                // Fridge details
                const fridgeDoor = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.8, 6.8),
                    new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
                );
                fridgeDoor.position.set(0, 0, 1.51);
                fridge.add(fridgeDoor);
                
                const fridgeHandle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 2, 8),
                    materials.metal
                );
                fridgeHandle.position.set(-1.2, 0, 1.6);
                fridgeHandle.rotation.z = Math.PI / 2;
                fridge.add(fridgeHandle);
                
                // Bedroom
                const bedroomGroup = new THREE.Group();
                // Adjusted bedroom position to be more centered in the room
                bedroomGroup.position.set(-12, 0, -15); // Changed from (-15, 0, -20) to (-12, 0, -15)
                houseGroup.add(bedroomGroup);
                
                // Bed
                const bed = new THREE.Group();
                
                // Bed frame
                const bedFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 1, 10),
                    materials.woodDark
                );
                bedFrame.position.set(0, 0.5, 0);
                bedFrame.castShadow = true;
                bedFrame.receiveShadow = true;
                bed.add(bedFrame);
                
                // Mattress
                const mattress = new THREE.Mesh(
                    new THREE.BoxGeometry(7.5, 1, 9.5),
                    new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.7 })
                );
                mattress.position.set(0, 1.5, 0);
                mattress.castShadow = true;
                mattress.receiveShadow = true;
                bed.add(mattress);
                
                // Pillows
                for (let i = -1; i <= 1; i+=2) {
                    const pillow = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.8, 2),
                        new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.7 })
                    );
                    pillow.position.set(i*2, 2, -3.5);
                    pillow.castShadow = true;
                    pillow.receiveShadow = true;
                    bed.add(pillow);
                }
                
                // Blanket
                const blanket = new THREE.Mesh(
                    new THREE.BoxGeometry(7.5, 0.3, 5),
                    materials.fabric
                );
                blanket.position.set(0, 2, 2);
                blanket.castShadow = true;
                blanket.receiveShadow = true;
                bed.add(blanket);
                
                // Headboard
                const headboard = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 4, 0.5),
                    materials.woodDark
                );
                headboard.position.set(0, 2.5, -5);
                headboard.castShadow = true;
                headboard.receiveShadow = true;
                bed.add(headboard);
                
                bed.rotation.y = Math.PI / 2;
                bedroomGroup.add(bed);
                
                // Bedside table
                const bedsideTable = new THREE.Group();
                
                // Table top
                const bedsideTableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.5, 2),
                    materials.woodDark
                );
                bedsideTableTop.position.set(0, 2, 0);
                bedsideTableTop.castShadow = true;
                bedsideTableTop.receiveShadow = true;
                bedsideTable.add(bedsideTableTop);
                
                // Table body
                const bedsideTableBody = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 2, 1.8),
                    materials.woodDark
                );
                bedsideTableBody.position.set(0, 1, 0);
                bedsideTableBody.castShadow = true;
                bedsideTableBody.receiveShadow = true;
                bedsideTable.add(bedsideTableBody);
                
                // Lamp on bedside table
                const lamp = new THREE.Group();
                
                // Lamp base
                const lampBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 0.2, 16),
                    materials.metal
                );
                lampBase.position.set(0, 0, 0);
                lampBase.castShadow = true;
                lampBase.receiveShadow = true;
                lamp.add(lampBase);
                
                // Lamp post
                const lampPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8),
                    materials.metal
                );
                lampPost.position.set(0, 0.6, 0);
                lampPost.castShadow = true;
                lampPost.receiveShadow = true;
                lamp.add(lampPost);
                
                // Lamp shade
                const lampShade = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.8, 0.7, 16, 1, true),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffffee, 
                        roughness: 0.5, 
                        emissive: 0xffffaa,
                        emissiveIntensity: 0.2 
                    })
                );
                lampShade.position.set(0, 1.2, 0);
                lampShade.castShadow = true;
                lamp.add(lampShade);
                
                // Lamp light
                const lampLight = new THREE.PointLight(0xffffaa, 0.8, 10);
                lampLight.position.set(0, 1.2, 0);
                lampLight.castShadow = true;
                lamp.add(lampLight);
                
                lamp.position.set(0, 2.25, 0);
                bedsideTable.add(lamp);
                
                bedsideTable.position.set(4, 0, 4); // Changed from (5, 0, 5) to (4, 0, 4)
                bedroomGroup.add(bedsideTable);
                
                // Wardrobe
                const wardrobe = new THREE.Group();
                
                // Wardrobe body
                const wardrobeBody = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 8, 1.5), // Reduced dimensions from (6, 8, 2) to (5, 8, 1.5)
                    materials.woodMedium
                );
                wardrobeBody.position.set(0, 4, 0);
                wardrobeBody.castShadow = true;
                wardrobeBody.receiveShadow = true;
                wardrobe.add(wardrobeBody);
                
                // Wardrobe doors
                for (let i = -1; i <= 1; i+=2) {
                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(2.4, 7.8, 0.2), // Adjusted width from 2.9 to 2.4
                        materials.woodLight
                    );
                    door.position.set(i*1.25, 4, 0.85); // Adjusted x from i*1.5 to i*1.25 and z from 1 to 0.85
                    door.castShadow = true;
                    door.receiveShadow = true;
                    wardrobe.add(door);
                    
                    // Door handle
                    const handle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                        materials.metal
                    );
                    handle.position.set(i*0.8, 4, 0.95); // Adjusted x from i*1 to i*0.8 and z from 1.1 to 0.95
                    handle.rotation.z = Math.PI / 2;
                    wardrobe.add(handle);
                }
                
                wardrobe.position.set(-5, 0, -4); // Changed from (-5, 0, -5) to (-5, 0, -4)
                bedroomGroup.add(wardrobe);
                
                // Bathroom
                const bathroomGroup = new THREE.Group();
                // Adjusted bathroom position to avoid wall intersections
                bathroomGroup.position.set(15, 0, -15); // Changed z from -20 to -15
                houseGroup.add(bathroomGroup);
                
                // Toilet
                const toilet = new THREE.Group();
                
                // Base
                const toiletBase = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.5, 2),
                    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 })
                );
                toiletBase.position.set(0, 0.25, 0);
                toiletBase.castShadow = true;
                toiletBase.receiveShadow = true;
                toilet.add(toiletBase);
                
                // Bowl
                const toiletBowl = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.5, 0.5, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 })
                );
                toiletBowl.position.set(0, 0.5, 0);
                toilet.add(toiletBowl);
                
                // Tank
                const toiletTank = new THREE.Mesh(
                    new THREE.BoxGeometry(1.4, 2, 0.8),
                    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 })
                );
                toiletTank.position.set(0, 1.5, -0.9);
                toiletTank.castShadow = true;
                toiletTank.receiveShadow = true;
                toilet.add(toiletTank);
                
                // Seat
                const toiletSeat = new THREE.Mesh(
                    new THREE.TorusGeometry(0.6, 0.2, 16, 32, Math.PI),
                    new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.5 })
                );
                toiletSeat.position.set(0, 0.7, 0);
                toiletSeat.rotation.x = Math.PI / 2;
                toiletSeat.rotation.z = Math.PI;
                toilet.add(toiletSeat);
                
                toilet.position.set(3, 0, -3); // Changed from (5, 0, -5) to (3, 0, -3)
                toilet.rotation.y = Math.PI;
                bathroomGroup.add(toilet);
                
                // Lighting for the entire house
                // Living room light
                const livingRoomLight = new THREE.PointLight(0xffffcc, 0.8, 40);
                livingRoomLight.position.set(0, houseDimensions.height - 1, 5); // Changed z from 10 to 5
                livingRoomLight.castShadow = true;
                livingRoomLight.shadow.mapSize.width = 1024;
                livingRoomLight.shadow.mapSize.height = 1024;
                houseGroup.add(livingRoomLight);
                
                // Kitchen light
                const kitchenLight = new THREE.PointLight(0xffffcc, 0.8, 30);
                kitchenLight.position.set(12, houseDimensions.height - 1, 0); // Changed x from 15 to 12
                kitchenLight.castShadow = true;
                kitchenLight.shadow.mapSize.width = 1024;
                kitchenLight.shadow.mapSize.height = 1024;
                houseGroup.add(kitchenLight);
                
                // Dining room light
                const diningRoomLight = new THREE.PointLight(0xffffcc, 0.8, 30);
                diningRoomLight.position.set(15, houseDimensions.height - 1, 10); // Changed z from 15 to 10
                diningRoomLight.castShadow = true;
                diningRoomLight.shadow.mapSize.width = 1024;
                diningRoomLight.shadow.mapSize.height = 1024;
                houseGroup.add(diningRoomLight);
                
                // Bedroom light
                const bedroomLight = new THREE.PointLight(0xffffcc, 0.8, 30);
                bedroomLight.position.set(-12, houseDimensions.height - 1, -15); // Changed from (-15, 0, -20) to (-12, 0, -15)
                bedroomLight.castShadow = true;
                bedroomLight.shadow.mapSize.width = 1024;
                bedroomLight.shadow.mapSize.height = 1024;
                houseGroup.add(bedroomLight);
                
                // Bathroom light
                const bathroomLight = new THREE.PointLight(0xffffcc, 0.8, 20);
                bathroomLight.position.set(15, houseDimensions.height - 1, -15); // Changed z from -20 to -15
                bathroomLight.castShadow = true;
                bathroomLight.shadow.mapSize.width = 1024;
                bathroomLight.shadow.mapSize.height = 1024;
                houseGroup.add(bathroomLight);

                // Initialize audio effects
                function initAudioEffects() {
                    // Set up ambient sounds
                    const ambientWind = document.getElementById('ambient-wind');
                    const distantThunder = document.getElementById('distant-thunder');
                    const eerieAmbient = document.getElementById('eerie-ambient');
                    
                    // Set volumes
                    ambientWind.volume = 0.3;
                    distantThunder.volume = 0.2;
                    eerieAmbient.volume = 0.15;
                    
                    // Start looping ambient sounds
                    document.addEventListener('click', () => {
                        ambientWind.play();
                        eerieAmbient.play();
                        
                        // Schedule random thunder sounds
                        scheduleThunderSounds();
                    }, { once: true });
                    
                    // Function to schedule random thunder sounds
                    function scheduleThunderSounds() {
                        const minDelay = 30000; // Minimum 30 seconds between thunder
                        const maxDelay = 120000; // Maximum 2 minutes
                        
                        const thunderDelay = minDelay + Math.random() * (maxDelay - minDelay);
                        
                        setTimeout(() => {
                            // Play thunder with random volume for distance effect
                            distantThunder.volume = 0.1 + Math.random() * 0.2;
                            distantThunder.currentTime = 0;
                            distantThunder.play();
                            
                            // Schedule next thunder
                            scheduleThunderSounds();
                        }, thunderDelay);
                    }
                }

                // Create array to store all collidable objects
                const collidableObjects = [];
                
                // Function to add an object to collidable list
                function addToCollidables(object) {
                    // If it's a mesh, add it directly
                    if (object.isMesh) {
                        collidableObjects.push(object);
                    }
                    
                    // If it's a group, add all its children recursively
                    if (object.children && object.children.length > 0) {
                        object.children.forEach(child => {
                            if (child.isMesh) {
                                collidableObjects.push(child);
                            } else if (child.children && child.children.length > 0) {
                                addToCollidables(child);
                            }
                        });
                    }
                }
                
                // Add walls and furniture to collidable objects
                addToCollidables(houseGroup);
                
                // Add trees and other outside objects to collidables
                scene.children.forEach(child => {
                    if (child.name === 'outsideGroup' || child.userData.collidable) {
                        addToCollidables(child);
                    }
                });
                
                // Mark all objects in the outsideGroup as collidable
                function markOutsideObjectsAsCollidable() {
                    const outsideGroup = scene.getObjectByName('outsideGroup');
                    if (outsideGroup) {
                        outsideGroup.traverse(function(object) {
                            if (object.isMesh) {
                                // Skip transparent objects with low opacity (non-collidable decorations)
                                if (object.material && object.material.transparent && object.material.opacity < 0.3) {
                                    return;
                                }
                                
                                object.userData.collidable = true;
                                collidableObjects.push(object);
                            }
                        });
                        console.log("Marked outside objects as collidable (except transparent decorations)");
                    }
                }
                
                // Call the function to mark outside objects
                markOutsideObjectsAsCollidable();
                
                animate(0);
                
                debugElement.textContent = "Game running - click to start!";
                
                // Initialize inventory system
                initInventorySystem();
                
            } catch (error) {
                debugElement.textContent = "Error: " + error.message;
                console.error(error);
            }
        };

    </script>
</body>
</html>
