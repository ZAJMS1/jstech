<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dystopian Escape - Through the Shadows</title>
    <link rel="stylesheet" href="css/styles.css">
    <!-- Updated to ES modules version of Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>
<script>
    // Add event listeners to restart buttons to clear inventory
    document.addEventListener('DOMContentLoaded', function() {
    // Auto-trigger border encounter
    setTimeout(() => {
      // Ensure game progress is properly set up
      if (typeof gameProgress === 'undefined') {
        window.gameProgress = {
          eventInProgress: false,
          borderReached: false,
          storyPhase: 'border',
          hasBackpack: localStorage.getItem('hasBackpack') === 'true'
        };
      }
      
      // Force trigger the border encounter directly
      console.log("Auto-triggering border encounter...");
      try {
        triggerBorderEncounter();
      } catch (error) {
        console.error("Error triggering border encounter:", error);
        
        // Fallback mechanism to go back to the main game if the page doesn't load
        setTimeout(() => {
          if (!document.getElementById('border-encounter')) {
            console.warn("Border encounter didn't appear, redirecting to game...");
            window.location.href = '/game';
          }
        }, 5000); // Wait 5 seconds before fallback redirect
      }
    }, 500); // Small delay to ensure page is loaded
    
    // Fix any displayMessage function issues
    window.displayMessage = window.displayMessage || function(message, duration) {
      console.log("Message:", message);
      const messageElement = document.createElement('div');
      messageElement.textContent = message;
      messageElement.style.position = 'absolute';
      messageElement.style.top = '10px';
      messageElement.style.left = '50%';
      messageElement.style.transform = 'translateX(-50%)';
      messageElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      messageElement.style.color = 'white';
      messageElement.style.padding = '10px 20px';
      messageElement.style.borderRadius = '5px';
      messageElement.style.fontFamily = 'Courier New, monospace';
      messageElement.style.fontSize = '16px';
      messageElement.style.zIndex = '100';
      document.body.appendChild(messageElement);
      
      setTimeout(() => {
        messageElement.style.opacity = '0';
        messageElement.style.transition = 'opacity 1s';
        setTimeout(() => messageElement.remove(), 1000);
      }, duration || 3000);
    };
        document.querySelectorAll('.restart-game, #restart-game').forEach(button => {
            button.addEventListener('click', function() {
                // Clear localStorage before restarting
                localStorage.removeItem('gameInventory');
                localStorage.removeItem('hasBackpack');
                console.log('Game restarting, inventory cleared');
            });
        });
    });
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background-color: #0a0a0a;
            color: #eee;
            overflow: hidden;
        }
        
        #pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .menu-container {
            background-color: rgba(30, 30, 40, 0.9);
            border: 2px solid #73a1ff;
            border-radius: 10px;
            padding: 30px;
            width: 350px;
            box-shadow: 0 0 20px #73a1ff;
            text-align: center;
        }
        
        .menu-container h2 {
            color: #73a1ff;
            font-size: 2rem;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 0.2rem;
            text-shadow: 0 0 10px #73a1ff;
        }
        
        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .menu-options button {
            padding: 12px;
            background-color: rgba(40, 40, 60, 0.9);
            border: 1px solid #73a1ff;
            color: #ccc;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            transition: all 0.2s ease;
            border-radius: 5px;
        }
        
        .menu-options button:hover {
            background-color: rgba(60, 60, 100, 0.9);
            color: #fff;
            box-shadow: 0 0 10px rgba(115, 161, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .menu-options button:active {
            transform: translateY(0);
        }
        
        #inventory-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 350px;
            background-color: rgba(20, 20, 40, 0.8);
            border: 2px solid #555;
            border-radius: 10px;
            display: none;
            z-index: 100;
            color: white;
            font-family: Arial, sans-serif;
            padding: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        }

        #inventory-title {
            text-align: center;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #666;
            font-size: 18px;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 10px;
            padding: 10px;
            height: calc(100% - 60px);
        }

        .inventory-slot {
            background-color: rgba(40, 40, 60, 0.7);
            border: 1px solid #777;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .inventory-slot:hover {
            background-color: rgba(60, 60, 90, 0.8);
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(100, 100, 255, 0.5);
        }

        .inventory-slot img {
            max-width: 80%;
            max-height: 80%;
            pointer-events: none;
        }

        .item-tooltip {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .inventory-slot:hover .item-tooltip {
            opacity: 1;
            z-index: 20;
            bottom: -35px;
            background-color: rgba(10, 10, 30, 0.9);
            box-shadow: 0 0 8px rgba(100, 100, 255, 0.5);
            color: #fff;
            font-weight: bold;
            border: 1px solid #555;
        }

        .item-count {
            position: absolute;
            bottom: 3px;
            right: 5px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 1px 4px;
            border-radius: 3px;
        }

        .key-tip {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 12px;
            color: #aaa;
        }
    </style>
<script src="js/save-system.js"></script>
</head>
<body>
    <div id="game-container">
        <div id="loading-screen">
            <div class="loading-text">Loading Dystopian World...</div>
        </div>
        
        <div id="pause-menu" style="display: none;">
            <div class="menu-container">
                <h2>Game Paused</h2>
                <div class="menu-options">
                    <button id="resume-game">Resume Game</button>
                    <button id="restart-game">Start Over</button>
                    <button id="save-quit">Save & Quit</button>
                    <button id="return-home">Return to Home</button>
                </div>
            </div>
        </div>

        <div id="info">
            <div class="controls-info">
                <p>WASD - Move | SPACE - Jump | MOUSE - Look | E - Inventory</p>
            </div>
        </div>
        <div id="debug"></div>
        <div id="inventory-panel">
            <h2 id="inventory-title">Inventory</h2>
            <div class="inventory-grid" id="inventory-grid"></div>
            <div class="key-tip">Press E to close</div>
        </div>

        <!-- Audio elements for ambient sounds -->
        <audio id="ambient-wind" preload="auto">
            <source src="audio/ambient-wind.mp3" type="audio/mp3">
        </audio>
        
    </div>
    
    <script type="module">
        import * as THREE from 'three';
        
        window.onload = function() {
                // Initialize saved position
                let savedPosition = null;
                
                // Load saved position if available
                try {
                    const savedData = localStorage.getItem('gameData');
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        if (parsedData && parsedData.position) {
                            savedPosition = parsedData.position;
                            console.log("Loaded saved position:", savedPosition);
                        }
                    }
                } catch (err) {
                    console.error("Error loading saved position:", err);
                }
            const debugElement = document.getElementById('debug');
            
            try {
                // Hide loading screen
                document.getElementById('loading-screen').style.display = 'none';
                
                // Initialize audio
                initAudioEffects();
                
                // Initialize event listeners for UI
                initEventListeners();
                
                // Game state
                const state = {
                    keysPressed: {},
                    playerVelocity: new THREE.Vector3(),
                    playerDirection: new THREE.Vector3(),
                    cameraOffset: new THREE.Vector3(0, 3, 7),
                    cameraRotation: { x: 0, y: 0 },
                    cameraMode: 'free', // Default camera mode: 'free' or 'shiftlock'
                    rightMouseDown: false,
                    mousePosition: { x: 0, y: 0 },
                    onGround: true,
                    movementSpeed: 0.25,
                    turnSpeed: 0.03,
                    jumpForce: 0.22,
                    gravity: 0.0125,
                    animationState: 'idle',
                    timeSinceLastStep: 0,
                    lastInputTime: 0,
                    autoAlignDelay: 2, // Seconds to wait before auto-aligning camera
                    movingDirection: null, // Current moving direction
                    idleTime: 0,
                    lastHeadMove: 0,
                    headTargetRotation: null,
                    headMoveDuration: 0,
                    headMoveStart: 0,
                    jumpPhase: null,
                    jumpTime: 0,
                    landingComplete: false, // Track if landing animation has completed
                    inventory: {
                        isOpen: false,
                        items: [],
                        slots: 15,
                        slotElements: [],
                        initialized: false
                    },
                    gamePaused: false, // Add pause state
                    spaceKeyReleased: true, // Track if space key has been released
                };
                
                // Initialize inventory system
                function initInventorySystemOld() { // Renamed to avoid conflict
                    // Only initialize once
                    if (state.inventory.initialized) return;
                    
                    // Mark as initialized
                    state.inventory.initialized = true;
                    
                    // Clear existing slots if any
                    const inventoryGrid = document.getElementById('inventory-grid');
                    if (!inventoryGrid) {
                        console.error("Inventory grid element not found!");
                        return;
                    }
                    
                    inventoryGrid.innerHTML = '';
                    state.inventory.slotElements = [];
                    
                    // Create inventory slots
                    for (let i = 0; i < state.inventory.slots; i++) {
                        const slot = document.createElement('div');
                        slot.className = 'inventory-slot';
                        slot.dataset.index = i;
                        slot.innerHTML = `<div class="item-tooltip"></div>`;
                        
                        // Add click handler for using items
                        slot.addEventListener('click', () => {
                            const item = state.inventory.items[i];
                            if (item) {
                                // Handle item usage (can be expanded later)
                                console.log(`Used item: ${item.name}`);
                            }
                        });
                        
                        inventoryGrid.appendChild(slot);
                        state.inventory.slotElements.push(slot);
                    }
                    
                    // Add some test items to inventory
                    addItemToInventory({
                        name: "Health Potion",
                        description: "Restores 25 health points",
                        icon: "🧪", // Using emoji for simplicity
                        count: 1
                    });
                    
                    addItemToInventory({
                        name: "Rusty Key",
                        description: "Might open something",
                        icon: "🔑",
                        count: 1
                    });
                    
                    console.log("Inventory system initialized with", state.inventory.slots, "slots");
                }

                // Add item to inventory
                function addItemToInventory(item) {
                    // Check if item already exists
                    const existingItemIndex = state.inventory.items.findIndex(i => 
                        i && i.name === item.name);
                    
                    if (existingItemIndex >= 0 && state.inventory.items[existingItemIndex].stackable !== false) {
                        // Increment count for existing item
                        state.inventory.items[existingItemIndex].count += item.count || 1;
                        updateInventoryDisplay();
                        return true;
                    } else {
                        // Find empty slot
                        const emptySlotIndex = state.inventory.items.findIndex(i => !i);
                        
                        if (emptySlotIndex >= 0 && emptySlotIndex < state.inventory.slots) {
                            // Add to empty slot
                            state.inventory.items[emptySlotIndex] = item;
                            updateInventoryDisplay();
                            return true;
                        } else if (state.inventory.items.length < state.inventory.slots) {
                            // Add to new slot
                            state.inventory.items.push(item);
                            updateInventoryDisplay();
                            return true;
                        }
                    }
                    
                    // Inventory full
                    console.log("Inventory full!");
                    return false;
                }

                // Update inventory display
                function updateInventoryDisplay() {
                    if (!state.inventory.initialized) return;
                    
                    // Remove any existing floating tooltips
                    document.querySelectorAll('.floating-tooltip').forEach(el => el.remove());
                    
                    for (let i = 0; i < state.inventory.slots; i++) {
                        const slot = state.inventory.slotElements[i];
                        if (!slot) continue;
                        
                        const item = state.inventory.items[i];
                        
                        if (item) {
                            // Update slot with item info
                            slot.innerHTML = `<div>${item.icon}</div>
                                ${item.count > 1 ? `<div class="item-count">${item.count}</div>` : ''}`;
                            
                            // Add mouseover event to show tooltip
                            slot.onmouseover = () => {
                                const rect = slot.getBoundingClientRect();
                                const tooltip = document.createElement('div');
                                tooltip.className = 'floating-tooltip';
                                tooltip.textContent = item.name;
                                tooltip.style.position = 'absolute';
                                tooltip.style.left = (rect.left + rect.width/2) + 'px';
                                tooltip.style.top = (rect.bottom + 10) + 'px';
                                tooltip.style.transform = 'translateX(-50%)';
                                tooltip.style.backgroundColor = 'rgba(10, 10, 30, 0.9)';
                                tooltip.style.color = 'white';
                                tooltip.style.padding = '5px 10px';
                                tooltip.style.borderRadius = '5px';
                                tooltip.style.fontWeight = 'bold';
                                tooltip.style.boxShadow = '0 0 8px rgba(100, 100, 255, 0.5)';
                                tooltip.style.zIndex = '999';
                                tooltip.style.pointerEvents = 'none';
                                tooltip.style.border = '1px solid #555';
                                document.body.appendChild(tooltip);
                            };
                            
                            // Add mouseout event to hide tooltip
                            slot.onmouseout = () => {
                                document.querySelectorAll('.floating-tooltip').forEach(el => el.remove());
                            };
                        } else {
                            // Empty slot
                            slot.innerHTML = '';
                            slot.onmouseover = null;
                            slot.onmouseout = null;
                        }
                    }
                }

                // Toggle inventory display
                function toggleInventory() {
                    // Use only the compact inventory in the top-right corner
                    if (window.playerInventory) {
                        // Toggle visibility of the compact inventory
                        const inventoryUI = document.getElementById('inventory-ui');
                        if (inventoryUI) {
                            const currentDisplay = inventoryUI.style.display;
                            inventoryUI.style.display = currentDisplay === 'none' ? 'block' : 'none';
                            console.log("Toggled compact inventory visibility");
                        } else {
                            console.log("Compact inventory UI not found");
                        }
                    }
                    
                    // No longer using the panel inventory
                    // const inventoryPanel = document.getElementById('inventory-panel');
                    // if (!inventoryPanel) {
                    //     console.error("Inventory panel element not found!");
                    //     return;
                    // }
                    
                    // state.inventory.isOpen = !state.inventory.isOpen;
                    // console.log("Toggle inventory:", state.inventory.isOpen);
                    
                    // if (state.inventory.isOpen) {
                    //     // Initialize inventory if not done yet (safety check)
                    //     if (!state.inventory.initialized) {
                    //         initInventorySystemOld();
                    //     }
                    //     
                    //     inventoryPanel.style.display = 'block';
                    //     updateInventoryDisplay();
                    //     console.log("Opened inventory");
                    // } else {
                    //     inventoryPanel.style.display = 'none';
                    //     console.log("Closed inventory");
                    // }
                }

                // Basic Three.js setup
                const scene = new THREE.Scene();
                
                // Update scene background and fog for a brighter ambiance
                scene.background = new THREE.Color(0x121212); // Dark background
                
                // Set up more realistic static fog for the entire scene
                // Use a denser FogExp2 for a more atmospheric effect
                scene.fog = new THREE.FogExp2(0x121212, 0.015); // Slightly less dense fog (0.02 -> 0.015)
                
                // Add a subtle color tint to the fog for better atmosphere
                const fogColor = new THREE.Color(0x121212);
                fogColor.lerp(new THREE.Color(0x334455), 0.1); // Blend in a slight blue tint
                scene.fog.color = fogColor;
                
                // Enhance ambient lighting - change to darker mood
                const ambientLight = new THREE.AmbientLight(0x555566, 0.6);
                scene.add(ambientLight);
                
                // Add directional light for natural moonlight effect
                const dirLight = new THREE.DirectionalLight(0x556677, 0.8);
                dirLight.position.set(30, 100, 30);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 1;
                dirLight.shadow.camera.far = 200;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                scene.add(dirLight);
                
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 60); // Position camera behind player
    camera.lookAt(0, 2, 0); // Look at where the player would be
                
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.getElementById('game-container').appendChild(renderer.domElement);
                
                // House removed
                const houseGroup = new THREE.Group(); // Empty group as placeholder
                // House removed
                
                // Materials library
                const materials = {
                    // Flooring
                    woodFloor: new THREE.MeshStandardMaterial({ 
                        color: 0x9b7653, 
                        roughness: 0.8,
                        metalness: 0.2
                    }),
                    tileFloor: new THREE.MeshStandardMaterial({ 
                        color: 0xd9d9d9, 
                        roughness: 0.7,
                        metalness: 0.1
                    }),
                    carpetFloor: new THREE.MeshStandardMaterial({ 
                        color: 0x496a81, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    
                    // Walls
                    wallExterior: new THREE.MeshStandardMaterial({ 
                        color: 0xe8e8e8, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    wallInterior: new THREE.MeshStandardMaterial({ 
                        color: 0xeaeaea, 
                        roughness: 0.9,
                        metalness: 0 
                    }),
                    
                    // Furniture
                    woodDark: new THREE.MeshStandardMaterial({ 
                        color: 0x5d4037, 
                        roughness: 0.8,
                        metalness: 0.1
                    }),
                    woodMedium: new THREE.MeshStandardMaterial({ 
                        color: 0x8d6e63, 
                        roughness: 0.8,
                        metalness: 0.1
                    }),
                    woodLight: new THREE.MeshStandardMaterial({ 
                        color: 0xbcaaa4, 
                        roughness: 0.8,
                        metalness: 0.1
                    }),
                    fabric: new THREE.MeshStandardMaterial({ 
                        color: 0x78909c, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    fabricDark: new THREE.MeshStandardMaterial({ 
                        color: 0x455a64, 
                        roughness: 0.9,
                        metalness: 0
                    }),
                    metal: new THREE.MeshStandardMaterial({ 
                        color: 0xb0bec5, 
                        roughness: 0.3,
                        metalness: 0.8
                    }),
                    glass: new THREE.MeshStandardMaterial({ 
                        color: 0xeceff1, 
                        roughness: 0.1,
                        metalness: 0.9,
                        transparent: true,
                        opacity: 0.3
                    }),
                    
                    // Roof
                    roofTiles: new THREE.MeshStandardMaterial({ 
                        color: 0x5d4037, 
                        roughness: 0.9,
                        metalness: 0.1
                    })
                };
                
                // Placeholder for houseDimensions to prevent reference errors
                const houseDimensions = {
                    width: 50,
                    length: 50,
                    height: 15,
                    wallThickness: 1
                };
                
                // Door and window dimensions - placeholder to prevent reference errors
                var frontDoorWidth = 6;
                var frontDoorHeight = 10;
                var frontWallHeight = houseDimensions.height * 0.9;
                var windowWidth = 5;
                var windowHeight = 5;
                
                // House removed - this is just a placeholder to prevent reference errors
                // Placeholder functions to prevent reference errors
                
                // Wall section creation function placeholder
                function createWallSection(width, height, depth, x, y, z, material) {
                    // Return empty mesh that doesn't render
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(0, 0, 0),
                        material
                    );
                    wall.position.set(x, y, z);
                    wall.visible = false; // Make invisible
                    return wall;
                }
                
                // Window creation function placeholder
                function createWindow(width, height, x, y, z, rotationY) {
                    // Return empty group that doesn't render
                    const windowGroup = new THREE.Group();
                    windowGroup.position.set(x, y, z);
                    windowGroup.rotation.y = rotationY || 0;
                    windowGroup.visible = false; // Make invisible
                    return windowGroup;
                }
                
                
                // House dimensions removed
                
                // Door and window dimensions removed
                
                // Create foundation - main floor
                const mainFloor = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        houseDimensions.width - 1, 
                        0.2, 
                        houseDimensions.length - 1
                    ),
                    materials.wallInterior
                );
                mainFloor.position.y = 0; // Position at ground level
                mainFloor.receiveShadow = true;
                // House element removed
                
                // Create ceiling - separate from the floor
                const ceiling = new THREE.Mesh(
                    new THREE.BoxGeometry(
                        houseDimensions.width - 1, 
                        0.2, 
                        houseDimensions.length - 1
                    ),
                    materials.wallInterior
                );
                ceiling.position.y = houseDimensions.height;
                ceiling.receiveShadow = true;
                // House element removed
                
                // Wall section creation function removed
                
                // Create outer walls
                // Back wall (full wall)
                const backWall = createWallSection(
                    houseDimensions.width, 
                    houseDimensions.height, 
                    houseDimensions.wallThickness,
                    0, 
                    houseDimensions.height / 2, 
                    -houseDimensions.length / 2,
                    materials.wallExterior
                );
                // House element removed
                
                // Left wall
                const leftWall = createWallSection(
                    houseDimensions.wallThickness, 
                    houseDimensions.height, 
                    houseDimensions.length,
                    -houseDimensions.width / 2, 
                    houseDimensions.height / 2, 
                    0,
                    materials.wallExterior
                );
                // House element removed
                
                // Right wall
                const rightWall = createWallSection(
                    houseDimensions.wallThickness, 
                    houseDimensions.height, 
                    houseDimensions.length,
                    houseDimensions.width / 2, 
                    houseDimensions.height / 2, 
                    0,
                    materials.wallExterior
                );
                // House element removed
                
                // Front wall with door opening
                // Left section
                const frontWallLeft = createWallSection(
                    (houseDimensions.width - frontDoorWidth) / 2, 
                    houseDimensions.height, 
                    houseDimensions.wallThickness,
                    -houseDimensions.width / 4 - frontDoorWidth / 4, 
                    houseDimensions.height / 2, 
                    houseDimensions.length / 2,
                    materials.wallExterior
                );
                // House element removed
                
                // Right section
                const frontWallRight = createWallSection(
                    (houseDimensions.width - frontDoorWidth) / 2, 
                    houseDimensions.height, 
                    houseDimensions.wallThickness,
                    houseDimensions.width / 4 + frontDoorWidth / 4, 
                    houseDimensions.height / 2, 
                    houseDimensions.length / 2,
                    materials.wallExterior
                );
                // House element removed
                
                // Top section
                const frontWallTop = createWallSection(
                    frontDoorWidth, 
                    houseDimensions.height - frontDoorHeight, 
                    houseDimensions.wallThickness,
                    0, 
                    houseDimensions.height - (houseDimensions.height - frontDoorHeight) / 2, 
                    houseDimensions.length / 2,
                    materials.wallExterior
                );
                // House element removed
                
                // Original window creation function removed
                
                // Add windows to the house
                // Front windows
                const frontWindowLeft = createWindow(
                    6, 5, 
                    -12, 6, 
                    houseDimensions.length / 2 + 0.1, 
                    0
                );
                // House element removed
                
                const frontWindowRight = createWindow(
                    6, 5, 
                    12, 6, 
                    houseDimensions.length / 2 + 0.1, 
                    0
                );
                // House element removed
                
                // Side windows
                const leftWindowFront = createWindow(
                    6, 5, 
                    -houseDimensions.width / 2 - 0.1, 6, 
                    15, 
                    Math.PI / 2
                );
                // House element removed
                
                const leftWindowBack = createWindow(
                    6, 5, 
                    -houseDimensions.width / 2 - 0.1, 6, 
                    -15, 
                    Math.PI / 2
                );
                // House element removed
                
                const rightWindowFront = createWindow(
                    6, 5, 
                    houseDimensions.width / 2 + 0.1, 6, 
                    15, 
                    -Math.PI / 2
                );
                // House element removed
                
                const rightWindowBack = createWindow(
                    6, 5, 
                    houseDimensions.width / 2 + 0.1, 6, 
                    -15, 
                    -Math.PI / 2
                );
                // House element removed
                
                // Back windows
                const backWindowLeft = createWindow(
                    6, 5, 
                    -12, 6, 
                    -houseDimensions.length / 2 - 0.1, 
                    Math.PI
                );
                // House element removed
                
                const backWindowMiddle = createWindow(
                    6, 5, 
                    0, 6, 
                    -houseDimensions.length / 2 - 0.1, 
                    Math.PI
                );
                // House element removed
                
                const backWindowRight = createWindow(
                    6, 5, 
                    12, 6, 
                    -houseDimensions.length / 2 - 0.1, 
                    Math.PI
                );
                // House element removed
                
                // Furniture
                // Table
                const smallTableHeight = 0.8;
                const smallTableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 1.2),
                    materials.woodMedium
                );
                smallTableTop.position.set(-2, smallTableHeight, -2);
                smallTableTop.castShadow = true;
                // House element removed
                
                // Table legs
                for (let x = -1; x <= 1; x += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        const tableLeg = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.05, smallTableHeight),
                            materials.woodDark
                        );
                        tableLeg.position.set(-2 + x * 0.9, smallTableHeight / 2, -2 + z * 0.5);
                        tableLeg.castShadow = true;
                        // House element removed
                    }
                }
                
                // Chairs
                function createChair(x, z, rotation) {
                    const chairGroup = new THREE.Group();
                    chairGroup.position.set(x, 0, z);
                    chairGroup.rotation.y = rotation;
                    
                    // Seat
                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.1, 0.6),
                        materials.woodMedium
                    );
                    seat.position.y = 0.45;
                    seat.castShadow = true;
                    chairGroup.add(seat);
                    
                    // Backrest
                    const back = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.5, 0.1),
                        materials.woodDark
                    );
                    back.position.set(0, 0.7, -0.25);
                    back.castShadow = true;
                    chairGroup.add(back);
                    
                    // Legs
                    for (let i = -1; i <= 1; i += 2) {
                        for (let j = -1; j <= 1; j += 2) {
                            const leg = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.04, 0.04, 0.45),
                                materials.woodDark
                            );
                            leg.position.set(i * 0.25, 0.225, j * 0.25);
                            leg.castShadow = true;
                            chairGroup.add(leg);
                        }
                    }
                    
                    return chairGroup;
                }
                
                houseGroup.add(createChair(-2, -3, 0));  // Front
                houseGroup.add(createChair(-2, -1, Math.PI));  // Back
                houseGroup.add(createChair(-3, -2, Math.PI/2));  // Left
                houseGroup.add(createChair(-1, -2, -Math.PI/2));  // Right
                
                // Bed
                const smallBedFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.3, 3),
                    materials.woodMedium
                );
                smallBedFrame.position.set(3, 0.15, -2);
                smallBedFrame.castShadow = true;
                // House element removed
                
                // Mattress
                const smallMattress = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.3, 2.8),
                    materials.fabric
                );
                smallMattress.position.set(3, 0.45, -2);
                smallMattress.castShadow = true;
                // House element removed
                
                // Pillow
                const pillow = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 0.2, 0.6),
                    materials.fabric
                );
                pillow.position.set(3, 0.7, -3.1);
                pillow.castShadow = true;
                // House element removed
                
                // Blanket
                const smallBlanket = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.1, 1.4),
                    materials.fabric
                );
                smallBlanket.position.set(3, 0.65, -1.4);
                smallBlanket.castShadow = true;
                // House element removed
                
                // Bookshelf
                const bookshelf = new THREE.Group();
                bookshelf.position.set(3, 0, -houseDimensions.length / 2 + 0.6);
                
                // Bookshelf frame
                const shelfFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2.5, 0.5),
                    materials.woodDark
                );
                bookshelf.add(shelfFrame);
                
                // Bookshelf back
                const shelfBack = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2.5, 0.05),
                    materials.woodDark
                );
                shelfBack.position.z = -0.225;
                bookshelf.add(shelfBack);
                
                // Bookshelf sides
                const leftSide = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 2.5, 0.5),
                    materials.woodDark
                );
                leftSide.position.x = -0.975;
                bookshelf.add(leftSide);
                
                const rightSide = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 2.5, 0.5),
                    materials.woodDark
                );
                rightSide.position.x = 0.975;
                bookshelf.add(rightSide);
                
                // Bookshelf shelves
                for (let i = 0; i < 5; i++) {
                    const shelf = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.05, 0.5),
                        materials.woodDark
                    );
                    shelf.position.y = -1.25 + i * 0.625;
                    bookshelf.add(shelf);
                    
                    // Add books on shelves
                    if (i > 0) {
                        const numBooks = Math.floor(Math.random() * 5) + 3;
                        const shelfWidth = 1.9;
                        const bookWidth = shelfWidth / numBooks;
                        
                        for (let j = 0; j < numBooks; j++) {
                            if (Math.random() > 0.25) { // Some gaps in the shelves
                                const bookHeight = 0.3 + Math.random() * 0.2;
                                const book = new THREE.Mesh(
                                    new THREE.BoxGeometry(bookWidth * 0.8, bookHeight, 0.2),
                                    new THREE.MeshStandardMaterial({ 
                                        color: new THREE.Color(
                                            Math.random() * 0.8, 
                                            Math.random() * 0.8, 
                                            Math.random() * 0.8
                                        ) 
                                    })
                                );
                                book.position.set(
                                    -0.95 + j * bookWidth + bookWidth / 2,
                                    -1.25 + i * 0.625 + bookHeight / 2 + 0.025,
                                    -0.1
                                );
                                book.castShadow = true;
                                bookshelf.add(book);
                            }
                        }
                    }
                }
                
                // House element removed
                
                // Add interior lighting
                const pointLight = new THREE.PointLight(0xffbb77, 0.8, 15);
                pointLight.position.set(0, houseDimensions.height - 0.5, 0);
                pointLight.castShadow = true;
                pointLight.shadow.mapSize.width = 1024;
                pointLight.shadow.mapSize.height = 1024;
                // House element removed
                
                // Add light "fixtures"
                const lightFixture = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffcc88, emissive: 0xffcc88, emissiveIntensity: 0.75 })
                );
                lightFixture.position.copy(pointLight.position);
                // House element removed
                
                // Position the player inside the house
                const player = createLowPolyCharacter();
    player.position.set(0, 1, 50); // Reset position
    scene.add(player); // Ensure player is added to scene
                player.position.set(0, 1, 50); // Starting position adjusted (outside)
                scene.add(player);
                
                // Create outside environment
                createOutsideEnvironment();
                
                // Function to create the outside dystopian environment
                function createOutsideEnvironment() {
                    // Create outside group
                    const outsideGroup = new THREE.Group();
                    outsideGroup.name = 'outsideGroup';
                    scene.add(outsideGroup);
                    
                    // Add atmospheric lighting for the outside
                    const moonLight = new THREE.DirectionalLight(0x334455, 0.5);
                    moonLight.position.set(-50, 80, -30);
                    moonLight.castShadow = true;
                    moonLight.shadow.mapSize.width = 2048;
                    moonLight.shadow.mapSize.height = 2048;
                    moonLight.shadow.camera.near = 1;
                    moonLight.shadow.camera.far = 300;
                    moonLight.shadow.camera.left = -100;
                    moonLight.shadow.camera.right = 100;
                    moonLight.shadow.camera.top = 100;
                    moonLight.shadow.camera.bottom = -100;
                    scene.add(moonLight);
                    
                    // Add some eerie flickering lights in the distance
                    for (let i = 0; i < 8; i++) {
                        const flickerLight = new THREE.PointLight(
                            // Random colors between orange/red (fire-like) and cold blue
                            Math.random() > 0.6 ? 0xff3300 : 0x0066aa,
                            0.8,
                            150
                        );
                        
                        // Position lights in the far distance
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 100 + Math.random() * 100;
                        flickerLight.position.set(
                            Math.sin(angle) * distance,
                            2 + Math.random() * 10,
                            Math.cos(angle) * distance
                        );
                        
                        // Create flickering animation
                        const flickerSpeed = 0.05 + Math.random() * 0.2;
                        const flickerIntensity = 0.2 + Math.random() * 0.8;
                        const baseIntensity = flickerLight.intensity;
                        
                        // Store animation data with the light
                        flickerLight.userData = {
                            flickerSpeed,
                            flickerIntensity,
                            baseIntensity,
                            timeOffset: Math.random() * 1000
                        };
                        
                        scene.add(flickerLight);
                        
                        // Add to list of lights to animate
                        if (!window.flickeringLights) window.flickeringLights = [];
                        window.flickeringLights.push(flickerLight);
                    }
                    
                    // Materials for outside elements
                    const materials = {
                        dirtyPath: new THREE.MeshStandardMaterial({
                            color: 0x333333,
                            roughness: 0.9,
                            metalness: 0.1
                        }),
                        deadGrass: new THREE.MeshStandardMaterial({
                            color: 0x0a1208, // Much darker, almost black-green
                            roughness: 0.95,
                            metalness: 0
                        }),
                        metal: new THREE.MeshStandardMaterial({
                            color: 0x665544,
                            roughness: 0.7,
                            metalness: 0.6
                        }),
                        rustyMetal: new THREE.MeshStandardMaterial({
                            color: 0x554433,
                            roughness: 0.8,
                            metalness: 0.4
                        }),
                        deadWood: new THREE.MeshStandardMaterial({
                            color: 0x1a1305, // Much darker brown, almost black
                            roughness: 0.9,
                            metalness: 0.1
                        }),
                        glass: new THREE.MeshStandardMaterial({
                            color: 0xaaaaaa,
                            roughness: 0.2,
                            metalness: 0.8,
                            transparent: true,
                            opacity: 0.3
                        }),
                        brokenGlass: new THREE.MeshStandardMaterial({
                            color: 0x777777,
                            roughness: 0.5,
                            metalness: 0.5,
                            transparent: true,
                            opacity: 0.2
                        })
                    };
                    
                    // Create large ground plane
                    const groundSize = 500;
                    const ground = new THREE.Mesh(
                        new THREE.PlaneGeometry(groundSize, groundSize),
                        materials.deadGrass
                    );
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.y = -0.1;
                    ground.receiveShadow = true;
                    outsideGroup.add(ground);
                    
                    // Create path leading to the house
                    const pathWidth = 5;
                    const pathLength = 200;
                    const path = new THREE.Mesh(
                        new THREE.PlaneGeometry(pathWidth, pathLength),
                        materials.dirtyPath
                    );
                    path.rotation.x = -Math.PI / 2;
                    path.position.set(0, 0.01, pathLength/2 - 20);
                    path.receiveShadow = true;
                    outsideGroup.add(path);
                    
                    // Add cracks and details to the path using small meshes
                    for (let i = 0; i < 40; i++) {
                        const crackSize = Math.random() * 1.5 + 0.5;
                        const crack = new THREE.Mesh(
                            new THREE.PlaneGeometry(crackSize, crackSize),
                            new THREE.MeshStandardMaterial({
                                color: 0x222222,
                                roughness: 1.0,
                                metalness: 0.0
                            })
                        );
                        crack.rotation.x = -Math.PI / 2;
                        crack.position.set(
                            (Math.random() - 0.5) * pathWidth * 0.8,
                            0.02,
                            (Math.random() * pathLength) - 20
                        );
                        crack.receiveShadow = true;
                        outsideGroup.add(crack);
                    }
                    
                    // Add street lights along the path (broken/shattered)
                    const streetLightCount = 20;
                    const streetLightSpacing = 15;
                    
                    for (let i = 0; i < streetLightCount; i++) {
                        // Randomly choose sides of the path instead of alternating
                        const side = Math.random() < 0.5 ? 1 : -1;
                        
                        // Create street light post and add tilt for damaged effect
                        const tiltAngle = (Math.random() - 0.5) * 0.5;
                        const postHeight = 5 + Math.random() * 2;
                        
                        const post = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.3, postHeight, 8),
                            materials.rustyMetal
                        );
                        
                        // Calculate position, ensuring z > 25 (outside the house)
                        const zPosition = Math.max(25, i * streetLightSpacing - 10);
                        
                        // Position with variation and tilt
                        post.position.set(
                            side * (pathWidth/2 + 1 + Math.random() * 3),
                            postHeight/2,
                            zPosition + (Math.random() - 0.5) * streetLightSpacing * 0.5
                        );
                        
                        // Apply tilt
                        post.rotation.z = tiltAngle;
                        if (Math.random() < 0.2) {
                            // Some posts are severely tilted
                            post.rotation.z = (Math.random() - 0.5) * 1.5;
                        }
                        
                        post.castShadow = true;
                        post.receiveShadow = true;
                        outsideGroup.add(post);
                        
                        // Lamp head with broken glass
                        if (Math.random() > 0.3) { // Some lights are completely missing
                            const lampHead = new THREE.Group();
                            
                            // Lamp housing
                            const housing = new THREE.Mesh(
                                new THREE.BoxGeometry(0.8, 0.5, 1.2),
                                materials.rustyMetal
                            );
                            
                            // Some lamp heads are damaged/dented
                            if (Math.random() > 0.5) {
                                housing.scale.set(
                                    1.0,
                                    1.0 - Math.random() * 0.4,
                                    1.0 - Math.random() * 0.3
                                );
                            }
                            
                            lampHead.add(housing);
                            
                            // Broken glass
                            if (Math.random() > 0.4) { // Some have no glass left
                                const glass = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.7, 0.4, 1.1),
                                    Math.random() > 0.5 ? materials.brokenGlass : materials.glass
                                );
                                glass.position.y = -0.05;
                                lampHead.add(glass);
                                
                                // Add a dim light to some working lamps
                                if (Math.random() < 0.2) {
                                    const light = new THREE.PointLight(0xaaaaaa, 0.5, 10);
                                    light.position.y = -0.2;
                                    lampHead.add(light);
                                }
                            }
                            
                            // Attach lamp to post
                            lampHead.position.set(0, postHeight, 0);
                            
                            // Random rotations for damaged/hanging lamps
                            if (Math.random() > 0.3) {
                                lampHead.rotation.x = (Math.random() - 0.5) * 0.6;
                                lampHead.rotation.z = (Math.random() - 0.5) * 0.4;
                            }
                            
                            post.add(lampHead);
                        }
                    }
                    
                    // Add dead trees and plants
                    for (let i = 0; i < 80; i++) {
                        const treeGroup = new THREE.Group();
                        
                        // Distance from path
                        const distFromPath = 3 + Math.random() * 40;
                        const side = Math.random() > 0.5 ? 1 : -1;
                        
                        // Tree trunk
                        const trunkHeight = 4 + Math.random() * 10;
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(
                                0.3 + Math.random() * 0.5,
                                0.5 + Math.random() * 0.7,
                                trunkHeight,
                                8
                            ),
                            materials.deadWood
                        );
                        trunk.position.y = trunkHeight / 2;
                        trunk.castShadow = true;
                        trunk.receiveShadow = true;
                        trunk.userData.collidable = true; // Mark as collidable
                        
                        // Add tilt for a creepy effect
                        trunk.rotation.z = (Math.random() - 0.5) * 0.4;
                        trunk.rotation.x = (Math.random() - 0.5) * 0.2;
                        
                        treeGroup.add(trunk);
                        
                        // Only larger trees get branches
                        if (trunkHeight > 7) {
                            // Add some twisted branches
                            const branchCount = Math.floor(Math.random() * 5) + 2;
                            
                            for (let j = 0; j < branchCount; j++) {
                                const branchLength = 1 + Math.random() * 4;
                                const branch = new THREE.Mesh(
                                    new THREE.CylinderGeometry(
                                        0.15,
                                        0.3,
                                        branchLength,
                                        6
                                    ),
                                    materials.deadWood
                                );
                                
                                // Position branch
                                const branchHeight = (Math.random() * 0.6 + 0.3) * trunkHeight;
                                branch.position.y = branchHeight - trunk.position.y;
                                
                                // Rotate to horizontal-ish position
                                branch.rotation.z = (Math.random() - 0.5) * Math.PI;
                                branch.rotation.y = Math.random() * Math.PI * 2;
                                
                                // Shift branch end position
                                branch.position.x = Math.sin(branch.rotation.z) * branchLength/2;
                                branch.position.y += Math.cos(branch.rotation.z) * branchLength/2;
                                
                                branch.castShadow = true;
                                trunk.add(branch);
                            }
                        }
                        
                        // Position the tree - ENSURE TREES ARE OUTSIDE THE HOUSE (z > 25)
                        // Generate a z position until we get one that's outside the house
                        let zPos;
                        do {
                            zPos = Math.random() * pathLength * 1.2 - 20;
                        } while (zPos < 25); // Keep regenerating until we get z > 25
                        
                        treeGroup.position.set(
                            side * (pathWidth/2 + distFromPath),
                            0,
                            zPos
                        );
                        
                        outsideGroup.add(treeGroup);
                    }
                    
                    // Add dead bushes and smaller vegetation
                    for (let i = 0; i < 150; i++) {
                        // Small dead bush
                        const bushSize = 0.5 + Math.random() * 1.5;
                        const bushHeight = 0.3 + Math.random() * 1.2;
                        
                        // Use an irregular shape for bushes
                        const bushGeometry = new THREE.SphereGeometry(
                            bushSize,
                            Math.floor(3 + Math.random() * 4),
                            Math.floor(2 + Math.random() * 3)
                        );
                        
                        // Deform the bush mesh to look dead and irregular
                        const bushVertices = bushGeometry.attributes.position;
                        for (let j = 0; j < bushVertices.count; j++) {
                            const x = bushVertices.getX(j);
                            const y = bushVertices.getY(j);
                            const z = bushVertices.getZ(j);
                            
                            const distort = (Math.random() - 0.5) * 0.4;
                            
                            bushVertices.setX(j, x * (1 + distort));
                            bushVertices.setZ(j, z * (1 + distort));
                            bushVertices.setY(j, y * (1 + (Math.random() - 0.2) * 0.5));
                        }
                        
                        // Create a variation of the dead grass material for bushes
                        const bushColor = new THREE.Color(0x0a1409); // Very dark green, almost black
                        // Minimal variations to stay extremely dark
                        bushColor.r += Math.random() * 0.02;
                        bushColor.g += Math.random() * 0.03;
                        bushColor.b += Math.random() * 0.01;
                        
                        const bushMaterial = new THREE.MeshStandardMaterial({
                            color: bushColor,
                            roughness: 0.9,
                            metalness: 0.1
                        });
                        
                        const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                        
                        // Position with large spread - ENSURE BUSHES ARE OUTSIDE THE HOUSE (z > 25)
                        const distFromPath = 3 + Math.random() * 100;
                        const side = Math.random() > 0.5 ? 1 : -1;
                        
                        // Generate a z position until we get one that's outside the house
                        let zPos;
                        do {
                            zPos = (Math.random() * pathLength * 2) - pathLength/2;
                        } while (zPos < 25); // Keep regenerating until we get z > 25
                        
                        bush.position.set(
                            side * (pathWidth/2 + distFromPath),
                            bushHeight/2,
                            zPos
                        );
                        
                        bush.castShadow = true;
                        bush.receiveShadow = true;
                        outsideGroup.add(bush);
                    }
                    
                    // Add some scattered debris and trash
                    const debrisTypes = [
                        // Metal scraps
                        {
                            geometry: new THREE.BoxGeometry(
                                Math.random() * 2 + 0.5,
                                Math.random() * 0.5 + 0.1,
                                Math.random() * 2 + 0.5
                            ),
                            material: materials.rustyMetal,
                            quantity: 30
                        },
                        // Concrete chunks
                        {
                            geometry: new THREE.DodecahedronGeometry(
                                Math.random() * 1.5 + 0.5,
                                0
                            ),
                            material: new THREE.MeshStandardMaterial({
                                color: 0x444444,
                                roughness: 0.9,
                                metalness: 0.1
                            }),
                            quantity: 25
                        },
                        // Broken wooden planks
                        {
                            geometry: new THREE.BoxGeometry(
                                Math.random() * 3 + 1,
                                Math.random() * 0.3 + 0.1,
                                Math.random() * 0.5 + 0.2
                            ),
                            material: materials.deadWood,
                            quantity: 20
                        }
                    ];
                    
                    // Add the debris
                    debrisTypes.forEach(debrisType => {
                        for (let i = 0; i < debrisType.quantity; i++) {
                            const geometry = debrisType.geometry.clone();
                            
                            // Randomize geometry scale slightly
                            const scale = 0.5 + Math.random() * 1.5;
                            
                            const debris = new THREE.Mesh(
                                geometry,
                                debrisType.material
                            );
                            
                            // Position within reasonable distance from path
                            const distFromPath = Math.random() * 30;
                            const side = Math.random() > 0.5 ? 1 : -1;
                            
                            // Generate a z position until we get one that's outside the house (z > 25)
                            let zPos;
                            do {
                                zPos = (Math.random() * pathLength * 1.5) - 30;
                            } while (zPos < 25); // Keep regenerating until we get z > 25
                            
                            debris.position.set(
                                side * (pathWidth/2 + distFromPath),
                                0.1 + Math.random() * 0.3,
                                zPos
                            );
                            
                            // Random rotation for natural look
                            debris.rotation.x = Math.random() * Math.PI;
                            debris.rotation.y = Math.random() * Math.PI;
                            debris.rotation.z = Math.random() * Math.PI;
                            
                            debris.scale.set(scale, scale, scale);
                            debris.castShadow = true;
                            debris.receiveShadow = true;
                            outsideGroup.add(debris);
                        }
                    });
                    
                    // Replace animated fog particles with a simple height fog effect
                    // This creates a more realistic atmospheric effect that doesn't look choppy
                    
                    // Add volumetric fog effect for atmosphere
                    function addAtmosphericFog(outsideGroup) {
                        const fogLight = new THREE.PointLight(0xccccff, 0.8, 120);
                        fogLight.position.set(0, 50, 50);
                        outsideGroup.add(fogLight);
                        
                        // Add volumetric haze for atmosphere
                        const hazeLight = new THREE.DirectionalLight(0x555577, 0.5);
                        hazeLight.position.set(-1, 1, 1);
                        hazeLight.lookAt(0, 0, 0);
                        outsideGroup.add(hazeLight);
                    }
                    
                    // Add tall glowing light rods along the path
                    function addGlowingLightRods(outsideGroup) {
                        // Create a material for the rod bodies
                        const rodMaterial = new THREE.MeshStandardMaterial({
                            color: 0x444444,
                            roughness: 0.7,
                            metalness: 0.5
                        });
                        
                        // Create a material for the glowing tips
                        const glowMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffcc00,
                            emissive: 0xffcc00,
                            emissiveIntensity: 1.00,
                            roughness: 0.3,
                            metalness: 0.8
                        });
                        
                        // Add several light rods along the path
                        const rodCount = 8;
                        const pathWidth = 5;
                        
                        for (let i = 0; i < rodCount; i++) {
                            // Create a group for the rod
                            const rodGroup = new THREE.Group();
                            
                            // Randomly choose sides of the path instead of alternating
                            const side = Math.random() < 0.5 ? 1 : -1;
                            
                            // Rod body
                            const rodHeight = 8 + Math.random() * 4; // Tall rods
                            const rod = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.15, 0.2, rodHeight, 8),
                                rodMaterial
                            );
                            rod.position.y = rodHeight / 2;
                            rod.castShadow = true;
                            rodGroup.add(rod);
                            
                            // Add horizontal arm at the top - now facing inward toward the path
                            const armLength = 1.5 + Math.random() * 0.5;
                            const arm = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.08, 0.08, armLength, 8),
                                rodMaterial
                            );
                            // Rotate to horizontal position
                            arm.rotation.z = Math.PI / 2;
                            // Position at the top of the rod, extend inward toward the path (negative side value)
                            arm.position.set(armLength/2 * -side, rodHeight, 0);
                            rodGroup.add(arm);
                            
                            // Add thin hanging wire
                            const wireHeight = 0.8 + Math.random() * 0.4;
                            const wire = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.02, 0.02, wireHeight, 8),
                                rodMaterial
                            );
                            wire.position.set(armLength * -side, rodHeight - wireHeight/2, 0);
                            rodGroup.add(wire);
                            
                            // Glowing lamp hanging from the arm
                            const glowLamp = new THREE.Mesh(
                                new THREE.SphereGeometry(0.3, 8, 8),
                                glowMaterial
                            );
                            glowLamp.position.set(armLength * -side, rodHeight - wireHeight, 0);
                            rodGroup.add(glowLamp);
                            
                            // Add a point light at the lamp
                            const light = new THREE.PointLight(0xffcc00, 1.5, 20);
                            light.position.copy(glowLamp.position);
                            
                            // Add slight flicker to some lights
                            if (Math.random() > 0.3) {
                                light.userData = {
                                    flickerSpeed: 0.02 + Math.random() * 0.05,
                                    flickerIntensity: 0.2,
                                    baseIntensity: light.intensity,
                                    timeOffset: Math.random() * 1000
                                };
                                
                                if (!window.flickeringLights) window.flickeringLights = [];
                                window.flickeringLights.push(light);
                            }
                            
                            rodGroup.add(light);
                            
                            // Position along the path, ensuring z > 25
                            // Choose a position further along the path (z > 25)
                            const zPosition = 30 + Math.random() * 150;
                            
                            // Position with some randomness
                            rodGroup.position.set(
                                side * (pathWidth/2 + 2 + Math.random() * 3),
                                0,
                                zPosition + (Math.random() - 0.5) * streetLightSpacing * 0.5
                            );
                            
                            // Add slight tilt for visual interest
                            rodGroup.rotation.z = (Math.random() - 0.5) * 0.2;
                            
                            outsideGroup.add(rodGroup);
                        }
                    }
                    
                    addAtmosphericFog(outsideGroup);
                    
                    // Function to add dystopian buildings to the outsideGroup
                    function addDystopianBuildings(outsideGroup) {
                        // Materials for buildings
                        const buildingMaterials = [
                            // Concrete/Stone buildings
                            new THREE.MeshStandardMaterial({
                                color: 0x333333, // Dark gray
                                roughness: 0.9,
                                metalness: 0.1
                            }),
                            new THREE.MeshStandardMaterial({
                                color: 0x555555, // Medium gray
                                roughness: 0.8,
                                metalness: 0.2
                            }),
                            new THREE.MeshStandardMaterial({
                                color: 0x222222, // Very dark gray
                                roughness: 0.7,
                                metalness: 0.3
                            }),
                            // Industrial/Metal buildings
                            new THREE.MeshStandardMaterial({
                                color: 0x444433, // Dark greenish gray
                                roughness: 0.6,
                                metalness: 0.4
                            }),
                            new THREE.MeshStandardMaterial({
                                color: 0x554433, // Dark brownish gray
                                roughness: 0.7,
                                metalness: 0.3
                            })
                        ];
                    
                        // Window material (dark with slight glow)
                        const windowMaterial = new THREE.MeshStandardMaterial({
                            color: 0x111111,
                            emissive: 0x222233,
                            emissiveIntensity: 0.30,
                            roughness: 0.5,
                            metalness: 0.8
                        });
                    
                        // Create buildings on both sides of the path
                        const buildingSides = [-1, 1]; // Left and right side
                        
                        // For each side of the path
                        buildingSides.forEach(side => {
                            // Base distance from path center
                            const baseDistance = 50; // 50 units away from path center
                            
                            // Create a dense area of buildings
                            for (let row = 0; row < 4; row++) {
                                // Row offset (further back for each row)
                                const rowOffset = row * 25;
                                
                                // Number of buildings in this row
                                const buildingsInRow = 6 + Math.floor(Math.random() * 3);
                                
                                for (let i = 0; i < buildingsInRow; i++) {
                                    // Vary the building dimensions
                                    const buildingWidth = 15 + Math.random() * 15;
                                    const buildingDepth = 15 + Math.random() * 15;
                                    const buildingHeight = 20 + Math.random() * 60; // Very different heights
                                    
                                    // Determine the building position
                                    // Buildings should be packed somewhat randomly but not overlap too much
                                    const xPosition = side * (baseDistance + rowOffset + (Math.random() - 0.5) * 10);
                                    const zPosition = 25 + i * buildingDepth * 1.2 + (Math.random() - 0.5) * 10;
                                    
                                    // Create the building
                                    const building = new THREE.Group();
                                    
                                    // Main building structure
                                    const structure = new THREE.Mesh(
                                        new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth),
                                        buildingMaterials[Math.floor(Math.random() * buildingMaterials.length)]
                                    );
                                    structure.position.set(0, buildingHeight/2, 0);
                                    structure.castShadow = true;
                                    structure.receiveShadow = true;
                                    building.add(structure);
                                    
                                    // Add windows (darker rectangles) on some buildings
                                    if (Math.random() > 0.3) {
                                        const windowRows = Math.floor(buildingHeight / 5);
                                        const windowCols = Math.floor(buildingWidth / 3);
                                        
                                        for (let row = 0; row < windowRows; row++) {
                                            // Skip some rows randomly
                                            if (Math.random() < 0.2) continue;
                                            
                                            for (let col = 0; col < windowCols; col++) {
                                                // Skip some windows randomly for variation
                                                if (Math.random() < 0.3) continue;
                                                
                                                // Window dimensions
                                                const windowWidth = 1.5;
                                                const windowHeight = 2;
                                                
                                                // Window position
                                                const windowX = -buildingWidth/2 + 2 + col * 3;
                                                const windowY = row * 5 + 3;
                                                const windowZ = buildingDepth/2 + 0.05; // Slightly outside the building
                                                
                                                // Create window
                                                const window = new THREE.Mesh(
                                                    new THREE.PlaneGeometry(windowWidth, windowHeight),
                                                    // Randomly choose if the window is lit
                                                    Math.random() < 0.2 ? 
                                                        new THREE.MeshStandardMaterial({
                                                            color: 0x111111,
                                                            emissive: 0xffffaa,
                                                            emissiveIntensity: 0.45 + Math.random() * 0.3,
                                                            roughness: 0.5,
                                                            metalness: 0.8
                                                        }) : windowMaterial
                                                );
                                                window.position.set(windowX, windowY, windowZ);
                                                window.rotation.y = Math.PI;
                                                building.add(window);
                                                
                                                // Add windows on other sides too
                                                const backWindow = window.clone();
                                                backWindow.position.z = -windowZ;
                                                backWindow.rotation.y = 0;
                                                building.add(backWindow);
                                                
                                                // Side windows (only on some buildings)
                                                if (Math.random() < 0.5 && col === 0) {
                                                    const sideWindow = window.clone();
                                                    sideWindow.position.set(buildingWidth/2 + 0.05, windowY, windowX * 2);
                                                    sideWindow.rotation.y = -Math.PI/2;
                                                    building.add(sideWindow);
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Add some rooftop features to some buildings
                                    if (Math.random() > 0.6) {
                                        // Water tower or AC unit or antenna
                                        if (Math.random() > 0.5) {
                                            // Water tower
                                            const towerBase = new THREE.Mesh(
                                                new THREE.BoxGeometry(buildingWidth * 0.3, buildingHeight * 0.05, buildingDepth * 0.3),
                                                buildingMaterials[2] // Dark material
                                            );
                                            towerBase.position.set(0, buildingHeight + 1, 0);
                                            building.add(towerBase);
                                            
                                            const waterTank = new THREE.Mesh(
                                                new THREE.CylinderGeometry(buildingWidth * 0.1, buildingWidth * 0.1, buildingHeight * 0.1, 8),
                                                buildingMaterials[3] // Metal material
                                            );
                                            waterTank.position.set(0, buildingHeight + 1 + buildingHeight * 0.075, 0);
                                            building.add(waterTank);
                                        } else {
                                            // Antenna or satellite dish
                                            const antenna = new THREE.Mesh(
                                                new THREE.CylinderGeometry(0.1, 0.2, buildingHeight * 0.15, 4),
                                                buildingMaterials[3] // Metal material
                                            );
                                            antenna.position.set(buildingWidth * 0.3, buildingHeight + buildingHeight * 0.075, buildingDepth * 0.3);
                                            building.add(antenna);
                                        }
                                    }
                                    
                                    // Position the entire building
                                    building.position.set(xPosition, 0, zPosition);
                                    
                                    // Slightly rotate some buildings for more natural look
                                    if (Math.random() > 0.7) {
                                        building.rotation.y = (Math.random() - 0.5) * 0.2;
                                    }
                                    
                                    outsideGroup.add(building);
                                }
                            }
                        });
                    }
                    
                    // Add the glowing light rods
                    addGlowingLightRods(outsideGroup);

                    // Add the dystopian buildings
                    addDystopianBuildings(outsideGroup);
                }
                
                // Remove this line from the original code since we've already positioned the player
                // scene.add(player);
                
                // First-person controls variables
                let moveForward = false;
                let moveBackward = false;
                let moveLeft = false;
                let moveRight = false;
                let canJump = true;
                
                // Lock and hide cursor
                const blocker = document.createElement('div');
                blocker.id = 'blocker';
                blocker.style.position = 'absolute';
                blocker.style.width = '100%';
                blocker.style.height = '100%';
                blocker.style.backgroundColor = 'rgba(0,0,0,0.5)';
                blocker.style.display = 'flex';
                blocker.style.justifyContent = 'center';
                blocker.style.alignItems = 'center';
                blocker.style.zIndex = '999';
                blocker.innerHTML = '<div style="color:white;font-size:24px;">Click to play</div>';
                document.body.appendChild(blocker);
                
                setupControls();
                
                function createLowPolyCharacter() {
                    // Create a group for the character
                    const character = new THREE.Group();
                    
                    // Create body parts with more rounded geometric shapes
                    
                    // Body - torso with curved shape
                    const torsoGeom = new THREE.CylinderGeometry(0.6, 0.5, 1.7, 8);
                    const torsoMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    const torso = new THREE.Mesh(torsoGeom, torsoMat);
                    torso.position.y = 1.2;
                    torso.castShadow = true;
                    character.add(torso);
                    character.torso = torso; // Reference for animations
                    
                    // Add shoulders - wider at the top
                    const shouldersGeom = new THREE.CylinderGeometry(0.7, 0.6, 0.4, 8);
                    const shouldersMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    const shoulders = new THREE.Mesh(shouldersGeom, shouldersMat);
                    shoulders.position.y = 2.0;
                    shoulders.castShadow = true;
                    character.add(shoulders);
                    character.shoulders = shoulders; // Reference for animations
                    
                    // Hip section
                    const hipGeom = new THREE.CylinderGeometry(0.5, 0.55, 0.3, 8);
                    const hipMat = new THREE.MeshStandardMaterial({ color: 0x222266, roughness: 0.7 });
                    const hip = new THREE.Mesh(hipGeom, hipMat);
                    hip.position.y = 0.5;
                    hip.castShadow = true;
                    character.add(hip);
                    
                    // Change the hair implementation to anchor it to the head
                    // Create a head group to contain all head parts
                    const headGroup = new THREE.Group();
                    headGroup.position.y = 2.5;
                    character.add(headGroup);
                    character.headGroup = headGroup;
                    
                    // Add the head to the head group with adjusted local position - make more spherical
                    const headGeom = new THREE.SphereGeometry(0.48, 16, 16);
                    const headMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 });
                    const head = new THREE.Mesh(headGeom, headMat);
                    head.position.y = 0; // Local position relative to headGroup
                    head.scale.set(1, 1.02, 0.95); // Very slight adjustments for natural look
                    head.castShadow = true;
                    headGroup.add(head);
                    character.head = head; // Reference for animations
                    
                    // Neck - positioned relative to character, not in head group
                    const neckGeom = new THREE.CylinderGeometry(0.25, 0.3, 0.3, 8);
                    const neckMat = new THREE.MeshStandardMaterial({ color: 0xdda688, roughness: 0.5 });
                    const neck = new THREE.Mesh(neckGeom, neckMat);
                    neck.position.y = 2.2;
                    neck.castShadow = true;
                    character.add(neck);
                    
                    // Hair - more spherical shape but stopping at forehead
                    const hairTopGeom = new THREE.SphereGeometry(0.52, 16, 16);
                    const hairMat = new THREE.MeshStandardMaterial({ color: 0x553322, roughness: 0.9 });
                    const hairTop = new THREE.Mesh(hairTopGeom, hairMat);
                    hairTop.position.y = 0.15; // Slightly elevated position
                    hairTop.position.z = -0.07; // Pull hair back from face
                    hairTop.scale.set(1, 0.85, 0.85); // Reduced depth to prevent forward extension
                    headGroup.add(hairTop);
                    
                    // Hair sides - more rounded with sphere geometry, also pulled back
                    const hairSideGeom = new THREE.SphereGeometry(0.52, 12, 12);
                    const hairSides = new THREE.Mesh(hairSideGeom, hairMat);
                    hairSides.position.set(0, 0.05, -0.1); // Positioned further back
                    hairSides.scale.set(1, 0.4, 0.7); // Reduced depth for sides
                    headGroup.add(hairSides);
                    
                    // Eyes and other facial features added to the head group
                    // Left eye white
                    const eyeWhiteGeom = new THREE.SphereGeometry(0.1, 10, 10);
                    const eyeWhiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const leftEyeWhite = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
                    leftEyeWhite.position.set(0.2, 0.05, 0.43);
                    headGroup.add(leftEyeWhite);
                    
                    // Left eye pupil
                    const eyeGeom = new THREE.SphereGeometry(0.08, 8, 8);
                    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                    leftEye.position.set(0.2, 0.05, 0.49);
                    headGroup.add(leftEye);
                    character.leftEye = leftEye; // Reference for animations
                    
                    // Right eye white
                    const rightEyeWhite = new THREE.Mesh(eyeWhiteGeom, eyeWhiteMat);
                    rightEyeWhite.position.set(-0.2, 0.05, 0.43);
                    headGroup.add(rightEyeWhite);
                    
                    // Right eye pupil
                    const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                    rightEye.position.set(-0.2, 0.05, 0.49);
                    headGroup.add(rightEye);
                    character.rightEye = rightEye; // Reference for animations
                    
                    // Eyelids
                    const eyelidGeom = new THREE.SphereGeometry(0.11, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const eyelidMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 });
                    
                    const leftEyelid = new THREE.Mesh(eyelidGeom, eyelidMat);
                    leftEyelid.position.set(0.2, 0.07, 0.43);
                    leftEyelid.rotation.x = Math.PI / 2;
                    headGroup.add(leftEyelid);
                    character.leftEyelid = leftEyelid; // Reference for animations
                    
                    const rightEyelid = new THREE.Mesh(eyelidGeom, eyelidMat);
                    rightEyelid.position.set(-0.2, 0.07, 0.43);
                    rightEyelid.rotation.x = Math.PI / 2;
                    headGroup.add(rightEyelid);
                    character.rightEyelid = rightEyelid; // Reference for animations
                    
                    // Mouth with more detail - make it curved
                    const mouthGeom = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
                    const mouthMat = new THREE.MeshBasicMaterial({ color: 0x662222 });
                    const mouth = new THREE.Mesh(mouthGeom, mouthMat);
                    mouth.position.set(0, -0.17, 0.47);
                    mouth.rotation.x = -Math.PI / 2;
                    mouth.scale.x = 0.8;
                    headGroup.add(mouth);
                    character.mouth = mouth; // Reference for animations
                    
                    // Nose with better shape
                    const noseGeom = new THREE.ConeGeometry(0.08, 0.12, 6);
                    const noseMat = new THREE.MeshStandardMaterial({ color: 0xdd9977 });
                    const nose = new THREE.Mesh(noseGeom, noseMat);
                    nose.rotation.x = -Math.PI / 2;
                    nose.position.set(0, -0.05, 0.5);
                    headGroup.add(nose);
                    
                    // Ears - more rounded
                    const earGeom = new THREE.SphereGeometry(0.12, 8, 8, Math.PI/2, Math.PI, 0, Math.PI);
                    const earMat = new THREE.MeshStandardMaterial({ color: 0xd3a286, roughness: 0.5 });
                    
                    const leftEar = new THREE.Mesh(earGeom, earMat);
                    leftEar.position.set(0.44, 0, 0);
                    leftEar.rotation.y = -Math.PI/2;
                    headGroup.add(leftEar);
                    
                    const rightEar = new THREE.Mesh(earGeom, earMat);
                    rightEar.position.set(-0.44, 0, 0);
                    rightEar.rotation.y = Math.PI/2;
                    headGroup.add(rightEar);
                    
                    // Arms with improved joints and segments for better folding
                    const jointMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    const armMat = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.7 });
                    const handMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.5 });
                    
                    // -- LEFT ARM --
                    // Shoulder socket joint
                    const shoulderJointGeom = new THREE.SphereGeometry(0.22, 12, 12);
                    const leftShoulderJoint = new THREE.Mesh(shoulderJointGeom, jointMat);
                    leftShoulderJoint.position.set(0.7, 2.0, 0);
                    leftShoulderJoint.castShadow = true;
                    character.add(leftShoulderJoint);
                    
                    // Main shoulder-to-elbow group
                    const leftArmGroup = new THREE.Group();
                    leftArmGroup.position.set(0.7, 2.0, 0);
                    character.add(leftArmGroup);
                    character.leftArmGroup = leftArmGroup;
                    
                    // Upper arm segment (shorter for more articulation points)
                    const upperArmGeom = new THREE.CylinderGeometry(0.18, 0.175, 0.4, 8);
                    const leftUpperArm = new THREE.Mesh(upperArmGeom, armMat);
                    leftUpperArm.position.y = -0.2;
                    leftUpperArm.castShadow = true;
                    leftArmGroup.add(leftUpperArm);
                    
                    // Mid-arm joint and group - new articulation point
                    const midArmJointGeom = new THREE.SphereGeometry(0.175, 12, 12);
                    const leftMidArmJoint = new THREE.Mesh(midArmJointGeom, jointMat);
                    leftMidArmJoint.position.y = -0.4;
                    leftMidArmJoint.castShadow = true;
                    leftArmGroup.add(leftMidArmJoint);
                    
                    // Mid-arm group
                    const leftMidArmGroup = new THREE.Group();
                    leftMidArmGroup.position.set(0, -0.4, 0);
                    leftArmGroup.add(leftMidArmGroup);
                    character.leftMidArmGroup = leftMidArmGroup;
                    
                    // Mid arm segment
                    const midArmGeom = new THREE.CylinderGeometry(0.175, 0.17, 0.35, 8);
                    const leftMidArm = new THREE.Mesh(midArmGeom, armMat);
                    leftMidArm.position.y = -0.175;
                    leftMidArm.castShadow = true;
                    leftMidArmGroup.add(leftMidArm);
                    
                    // Elbow joint
                    const elbowJointGeom = new THREE.SphereGeometry(0.17, 12, 12);
                    const leftElbowJoint = new THREE.Mesh(elbowJointGeom, jointMat);
                    leftElbowJoint.position.y = -0.35;
                    leftElbowJoint.castShadow = true;
                    leftMidArmGroup.add(leftElbowJoint);
                    
                    // Forearm group
                    const leftForearmGroup = new THREE.Group();
                    leftForearmGroup.position.set(0, -0.35, 0);
                    leftMidArmGroup.add(leftForearmGroup);
                    character.leftForearmGroup = leftForearmGroup;
                    
                    // Upper forearm segment
                    const upperForearmGeom = new THREE.CylinderGeometry(0.17, 0.165, 0.3, 8);
                    const leftUpperForearm = new THREE.Mesh(upperForearmGeom, armMat);
                    leftUpperForearm.position.y = -0.15;
                    leftUpperForearm.castShadow = true;
                    leftForearmGroup.add(leftUpperForearm);
                    
                    // Wrist joint - new joint for better hand rotation
                    const wristJointGeom = new THREE.SphereGeometry(0.165, 12, 12);
                    const leftWristJoint = new THREE.Mesh(wristJointGeom, jointMat);
                    leftWristJoint.position.y = -0.3;
                    leftWristJoint.castShadow = true;
                    leftForearmGroup.add(leftWristJoint);
                    
                    // Hand/wrist group
                    const leftHandGroup = new THREE.Group();
                    leftHandGroup.position.set(0, -0.3, 0);
                    leftForearmGroup.add(leftHandGroup);
                    character.leftHandGroup = leftHandGroup;
                    
                    // Lower forearm
                    const lowerForearmGeom = new THREE.CylinderGeometry(0.165, 0.16, 0.25, 8);
                    const leftLowerForearm = new THREE.Mesh(lowerForearmGeom, armMat);
                    leftLowerForearm.position.y = -0.125;
                    leftLowerForearm.castShadow = true;
                    leftHandGroup.add(leftLowerForearm);
                    
                    // Hand
                    const handGeom = new THREE.SphereGeometry(0.15, 12, 12);
                    const leftHand = new THREE.Mesh(handGeom, handMat);
                    leftHand.position.y = -0.25;
                    leftHand.castShadow = true;
                    leftHandGroup.add(leftHand);
                    
                    // -- RIGHT ARM --
                    // Shoulder socket joint
                    const rightShoulderJoint = new THREE.Mesh(shoulderJointGeom, jointMat);
                    rightShoulderJoint.position.set(-0.7, 2.0, 0);
                    rightShoulderJoint.castShadow = true;
                    character.add(rightShoulderJoint);
                    
                    // Main shoulder-to-elbow group
                    const rightArmGroup = new THREE.Group();
                    rightArmGroup.position.set(-0.7, 2.0, 0);
                    character.add(rightArmGroup);
                    character.rightArmGroup = rightArmGroup;
                    
                    // Upper arm segment
                    const rightUpperArm = new THREE.Mesh(upperArmGeom, armMat);
                    rightUpperArm.position.y = -0.2;
                    rightUpperArm.castShadow = true;
                    rightArmGroup.add(rightUpperArm);
                    
                    // Mid-arm joint and group - new articulation point

                    // Mid-arm joint and group - new articulation point
const rightMidArmGroup = new THREE.Group();
                    rightMidArmGroup.position.set(0, -0.4, 0);
                    rightArmGroup.add(rightMidArmGroup);
                    character.rightMidArmGroup = rightMidArmGroup;
                    
                    // Mid arm segment
                    const rightMidArm = new THREE.Mesh(midArmGeom, armMat);
                    rightMidArm.position.y = -0.175;
                    rightMidArm.castShadow = true;
                    rightMidArmGroup.add(rightMidArm);
                    
                    // Elbow joint
                    const rightElbowJoint = new THREE.Mesh(elbowJointGeom, jointMat);
                    rightElbowJoint.position.y = -0.35;
                    rightElbowJoint.castShadow = true;
                    rightMidArmGroup.add(rightElbowJoint);
                    
                    // Forearm group
                    const rightForearmGroup = new THREE.Group();
                    rightForearmGroup.position.set(0, -0.35, 0);
                    rightMidArmGroup.add(rightForearmGroup);
                    character.rightForearmGroup = rightForearmGroup;
                    
                    // Upper forearm segment
                    const rightUpperForearm = new THREE.Mesh(upperForearmGeom, armMat);
                    rightUpperForearm.position.y = -0.15;
                    rightUpperForearm.castShadow = true;
                    rightForearmGroup.add(rightUpperForearm);
                    
                    // Wrist joint - new joint for better hand rotation
                    const rightWristJoint = new THREE.Mesh(wristJointGeom, jointMat);
                    rightWristJoint.position.y = -0.3;
                    rightWristJoint.castShadow = true;
                    rightForearmGroup.add(rightWristJoint);
                    
                    // Hand/wrist group
                    const rightHandGroup = new THREE.Group();
                    rightHandGroup.position.set(0, -0.3, 0);
                    rightForearmGroup.add(rightHandGroup);
                    character.rightHandGroup = rightHandGroup;
                    
                    // Lower forearm
                    const rightLowerForearm = new THREE.Mesh(lowerForearmGeom, armMat);
                    rightLowerForearm.position.y = -0.125;
                    rightLowerForearm.castShadow = true;
                    rightHandGroup.add(rightLowerForearm);
                    
                    // Hand
                    const rightHand = new THREE.Mesh(handGeom, handMat);
                    rightHand.position.y = -0.25;
                    rightHand.castShadow = true;
                    rightHandGroup.add(rightHand);
                    
                    // Legs with joints
                    // Hip joints
                    const hipJointGeom = new THREE.SphereGeometry(0.22, 12, 12);
                    const legJointMat = new THREE.MeshStandardMaterial({ color: 0x222266, roughness: 0.7 });
                    
                    // ... rest of the character creation function
                    // ... existing leg creation code

                    // Hip joints
                    const leftHipJoint = new THREE.Mesh(hipJointGeom, legJointMat);
                    leftHipJoint.position.set(0.3, 0.4, 0);
                    leftHipJoint.castShadow = true;
                    character.add(leftHipJoint);
                    
                    const rightHipJoint = new THREE.Mesh(hipJointGeom, legJointMat);
                    rightHipJoint.position.set(-0.3, 0.4, 0);
                    rightHipJoint.castShadow = true;
                    character.add(rightHipJoint);
                    
                    // Leg groups for animation
                    const leftLegGroup = new THREE.Group();
                    leftLegGroup.position.set(0.3, 0.4, 0);
                    character.add(leftLegGroup);
                    character.leftLegGroup = leftLegGroup;
                    
                    const rightLegGroup = new THREE.Group();
                    rightLegGroup.position.set(-0.3, 0.4, 0);
                    character.add(rightLegGroup);
                    character.rightLegGroup = rightLegGroup;
                    
                    // Upper legs (thighs)
                    const thighGeom = new THREE.CylinderGeometry(0.18, 0.17, 0.7, 8);
                    const legMat = new THREE.MeshStandardMaterial({ color: 0x222266, roughness: 0.7 });
                    
                    const leftThigh = new THREE.Mesh(thighGeom, legMat);
                    leftThigh.position.y = -0.35;
                    leftThigh.castShadow = true;
                    leftLegGroup.add(leftThigh);
                    
                    const rightThigh = new THREE.Mesh(thighGeom, legMat);
                    rightThigh.position.y = -0.35;
                    rightThigh.castShadow = true;
                    rightLegGroup.add(rightThigh);
                    
                    // Knee joints
                    const kneeJointGeom = new THREE.SphereGeometry(0.17, 12, 12);
                    
                    const leftKneeJoint = new THREE.Mesh(kneeJointGeom, legJointMat);
                    leftKneeJoint.position.y = -0.7;
                    leftKneeJoint.castShadow = true;
                    leftLegGroup.add(leftKneeJoint);
                    
                    const rightKneeJoint = new THREE.Mesh(kneeJointGeom, legJointMat);
                    rightKneeJoint.position.y = -0.7;
                    rightKneeJoint.castShadow = true;
                    rightLegGroup.add(rightKneeJoint);
                    
                    // Lower leg groups
                    const leftCalfGroup = new THREE.Group();
                    leftCalfGroup.position.set(0, -0.7, 0);
                    leftLegGroup.add(leftCalfGroup);
                    character.leftCalfGroup = leftCalfGroup;
                    
                    const rightCalfGroup = new THREE.Group();
                    rightCalfGroup.position.set(0, -0.7, 0);
                    rightLegGroup.add(rightCalfGroup);
                    character.rightCalfGroup = rightCalfGroup;
                    
                    // Lower legs (calves)
                    const calfGeom = new THREE.CylinderGeometry(0.16, 0.15, 0.65, 8);
                    
                    const leftCalf = new THREE.Mesh(calfGeom, legMat);
                    leftCalf.position.y = -0.325;
                    leftCalf.castShadow = true;
                    leftCalfGroup.add(leftCalf);
                    
                    const rightCalf = new THREE.Mesh(calfGeom, legMat);
                    rightCalf.position.y = -0.325;
                    rightCalf.castShadow = true;
                    rightCalfGroup.add(rightCalf);
                    
                    // Ankle joints
                    const ankleJointGeom = new THREE.SphereGeometry(0.15, 12, 12);
                    
                    const leftAnkle = new THREE.Mesh(ankleJointGeom, legJointMat);
                    leftAnkle.position.y = -0.65;
                    leftAnkle.castShadow = true;
                    leftCalfGroup.add(leftAnkle);
                    
                    const rightAnkle = new THREE.Mesh(ankleJointGeom, legJointMat);
                    rightAnkle.position.y = -0.65;
                    rightAnkle.castShadow = true;
                    rightCalfGroup.add(rightAnkle);
                    
                    // Feet
                    const footGeom = new THREE.BoxGeometry(0.35, 0.15, 0.5);
                    footGeom.translate(0, 0, 0.1); // Move origin to heel
                    const footMat = new THREE.MeshStandardMaterial({ color: 0x554433, roughness: 0.8 });
                    
                    const leftFoot = new THREE.Mesh(footGeom, footMat);
                    leftFoot.position.y = -0.72;
                    leftFoot.castShadow = true;
                    leftCalfGroup.add(leftFoot);
                    
                    const rightFoot = new THREE.Mesh(footGeom, footMat);
                    rightFoot.position.y = -0.72;
                    rightFoot.castShadow = true;
                    rightCalfGroup.add(rightFoot);
                    
                    return character;
                }
                
                function setupControls() {
                    // Handle pointer lock
                    document.addEventListener('click', function(event) {
                        // Only lock pointer in shiftlock mode or when right mouse is not pressed
                        if (state.cameraMode === 'shiftlock' && event.button === 0) {
                            document.body.requestPointerLock = document.body.requestPointerLock || 
                                                            document.body.mozRequestPointerLock ||
                                                            document.body.webkitRequestPointerLock;
                            document.body.requestPointerLock();
                        }
                    });
                    
                    document.addEventListener('pointerlockchange', lockChangeHandler, false);
                    document.addEventListener('mozpointerlockchange', lockChangeHandler, false);
                    document.addEventListener('webkitpointerlockchange', lockChangeHandler, false);
                    
                    // Track mouse movement for free camera mode
                    document.addEventListener('mousemove', function(event) {
                        // Handle right-click drag in free mode
                        if (state.cameraMode === 'free' && state.rightMouseDown) {
                            const deltaX = event.clientX - state.mousePosition.x;
                            const deltaY = event.clientY - state.mousePosition.y;
                            
                            // Update camera rotation
                            state.cameraRotation.y -= deltaX * 0.01;
                            state.cameraRotation.x -= deltaY * 0.01;
                            
                            // Clamp vertical rotation
                            state.cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, state.cameraRotation.x));
                            
                            // Reset mouse position to its original point when right-click started
                            if (document.pointerLockElement !== document.body) {
                                window.scrollTo(window.scrollX, window.scrollY); // Prevent page scrolling
                            }
                        }
                    });
                    
                    // Prevent default drag behavior
                    document.addEventListener('dragstart', function(event) {
                        if (state.rightMouseDown) {
                            event.preventDefault();
                        }
                    });
                    
                    // Handle right mouse button for orbital camera
                    document.addEventListener('mousedown', function(event) {
                        if (event.button === 2) { // Right mouse button
                            state.rightMouseDown = true;
                            state.mousePosition.x = event.clientX;
                            state.mousePosition.y = event.clientY;
                            
                            // Request pointer lock for right-click camera control in free mode
                            if (state.cameraMode === 'free') {
                                document.body.requestPointerLock = document.body.requestPointerLock || 
                                                                document.body.mozRequestPointerLock ||
                                                                document.body.webkitRequestPointerLock;
                                document.body.requestPointerLock();
                            }
                            
                            event.preventDefault();
                        }
                    });
                    
                    document.addEventListener('mouseup', function(event) {
                        if (event.button === 2) { // Right mouse button
                            state.rightMouseDown = false;
                            
                            // Exit pointer lock when releasing right-click in free mode
                            if (state.cameraMode === 'free' && document.pointerLockElement === document.body) {
                                document.exitPointerLock();
                            }
                            
                            event.preventDefault();
                        }
                    });
                    
                    // Prevent context menu on right-click
                    document.addEventListener('contextmenu', function(event) {
                        event.preventDefault();
                    });
                    
                    function lockChangeHandler() {
                        if (document.pointerLockElement === document.body || 
                            document.mozPointerLockElement === document.body ||
                            document.webkitPointerLockElement === document.body) {
                            blocker.style.display = 'none';
                            document.addEventListener('mousemove', handleMouseMove, false);
                        } else {
                            // Only show blocker in shiftlock mode
                            if (state.cameraMode === 'shiftlock') {
                                blocker.style.display = 'flex';
                            } else {
                                blocker.style.display = 'none';
                            }
                            document.removeEventListener('mousemove', handleMouseMove, false);
                        }
                    }
                    
                    function handleMouseMove(event) {
                        // Only process in shiftlock mode or when right mouse is down in free mode
                        if (document.pointerLockElement === document.body || 
                            document.mozPointerLockElement === document.body ||
                            document.webkitPointerLockElement === document.body) {
                            
                            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                            
                            if (state.cameraMode === 'shiftlock' || (state.cameraMode === 'free' && state.rightMouseDown)) {
                                // Update camera rotation
                                state.cameraRotation.y -= movementX * 0.01;
                                state.cameraRotation.x -= movementY * 0.01;
                                
                                // Clamp vertical rotation to prevent flipping
                                state.cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, state.cameraRotation.x));
                                
                                // Update player rotation to match camera horizontal rotation in shiftlock mode
                                if (state.cameraMode === 'shiftlock') {
                                    player.rotation.y = state.cameraRotation.y;
                                }
                            }
                        }
                    }
                    
                    // Update the blocker text based on camera mode
                    function updateBlockerText() {
                        if (state.cameraMode === 'shiftlock') {
                            blocker.innerHTML = '<div style="color:white;font-size:24px;">Click to play (Shift-Lock Mode)</div>';
                        } else {
                            blocker.style.display = 'none';
                        }
                    }
                    
                    // Handle shift key to toggle camera modes
                    document.addEventListener('keydown', function(event) {
                        if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                            // Toggle camera mode
                            state.cameraMode = state.cameraMode === 'shiftlock' ? 'free' : 'shiftlock';
                            
                            // Update debug info
                            debugElement.textContent = `Camera Mode: ${state.cameraMode}`;
                            
                            // Request pointer lock automatically when shifting to shiftlock mode
                            if (state.cameraMode === 'shiftlock') {
                                document.body.requestPointerLock = document.body.requestPointerLock || 
                                                               document.body.mozRequestPointerLock ||
                                                               document.body.webkitRequestPointerLock;
                                document.body.requestPointerLock();
                            }
                            // If switching to free mode, exit pointer lock
                            else if (document.pointerLockElement === document.body) {
                                document.exitPointerLock();
                            }
                            
                            // Update blocker text
                            updateBlockerText();
                        }
                    });
                    
                    // Initialize blocker text
                    updateBlockerText();
                }
                
                // Set up key controls
                document.addEventListener('keydown', function(event) {
                    switch (event.code) {
                        case 'KeyW':
                            moveForward = true;
                            break;
                        case 'KeyA':
                            moveLeft = true;
                            break;
                        case 'KeyS':
                            moveBackward = true;
                            break;
                        case 'KeyD':
                            moveRight = true;
                            break;
                        case 'KeyE':
                            // Toggle inventory when E is pressed
                            console.log("E key pressed - toggling inventory");
                            toggleInventory();
                            break;
                        case 'Space':
                            if (canJump) {
                                state.playerVelocity.y = state.jumpForce;
                                canJump = false;
                                // Explicitly reset jump animation state to ensure it starts fresh each time
                                state.jumpPhase = "startup";
                                state.jumpTime = 0;
                                state.landingComplete = false; // Track if landing animation has completed
                            }
                            break;
                    }
                });
                
                document.addEventListener('keyup', function(event) {
                    switch (event.code) {
                        case 'KeyW':
                            moveForward = false;
                            break;
                        case 'KeyA':
                            moveLeft = false;
                            break;
                        case 'KeyS':
                            moveBackward = false;
                            break;
                        case 'KeyD':
                            moveRight = false;
                            break;
                        case 'Space':
                            // Mark that space key has been released
                            state.spaceKeyReleased = true;
                            state.keysPressed['Space'] = false;
                            break;
                    }
                });
                
                // Animation functions for the character
                function animateCharacter(delta) {
                    // Determine animation state
                    if (!canJump) {
                        state.animationState = 'jumping';
                    } else if (!state.landingComplete && state.jumpPhase === "landing") {
                        // Keep in jumping state until landing animation completes
                        state.animationState = 'jumping';
                    } else if (moveForward || moveBackward || moveLeft || moveRight) {
                        state.animationState = 'walking';
                    } else {
                        state.animationState = 'idle';
                    }
                    
                    // Reset all animations first
                    resetCharacterPose();
                    
                    // Apply animation based on state
                    if (state.animationState === 'idle') {
                        idleAnimation(delta);
                    } else if (state.animationState === 'walking') {
                        walkingAnimation(delta);
                    } else if (state.animationState === 'jumping') {
                        jumpingAnimation(delta);
                    }
                }
                
                // Reset animation state functions for the original model
                function resetCharacterPose() {
                    // Reset all arm positions to normal
                    if (player.leftArmGroup) {
                        player.leftArmGroup.rotation.set(0, 0, 0);
                        player.leftArmGroup.position.z = 0;
                    }
                    
                    if (player.rightArmGroup) {
                        player.rightArmGroup.rotation.set(0, 0, 0);
                        player.rightArmGroup.position.z = 0;
                    }
                    
                    if (player.leftMidArmGroup) player.leftMidArmGroup.rotation.set(0, 0, 0);
                    if (player.rightMidArmGroup) player.rightMidArmGroup.rotation.set(0, 0, 0);
                    if (player.leftForearmGroup) player.leftForearmGroup.rotation.set(0, 0, 0);
                    if (player.rightForearmGroup) player.rightForearmGroup.rotation.set(0, 0, 0);
                    if (player.leftHandGroup) player.leftHandGroup.rotation.set(0, 0, 0);
                    if (player.rightHandGroup) player.rightHandGroup.rotation.set(0, 0, 0);
                    
                    // Reset leg rotations
                    if (player.leftLegGroup) {
                        player.leftLegGroup.rotation.set(0, 0, 0);
                    }
                    if (player.rightLegGroup) {
                        player.rightLegGroup.rotation.set(0, 0, 0);
                    }
                    if (player.leftCalfGroup) player.leftCalfGroup.rotation.set(0, 0, 0);
                    if (player.rightCalfGroup) player.rightCalfGroup.rotation.set(0, 0, 0);
                    
                    if (player.shoulders) player.shoulders.rotation.y = 0;
                    if (player.torso) {
                        player.torso.rotation.x = 0;
                        player.torso.rotation.y = 0;
                    }
                    
                    // Reset head position if it was modified
                    if (player.headGroup) {
                        player.headGroup.rotation.set(0, 0, 0);
                    }
                }
                
                function idleAnimation(delta) {
                    // Track animation time
                    state.idleTime = (state.idleTime || 0) + delta;
                    
                    // Subtle breathing motion with enhanced movement
                    const breathAmount = Math.sin(Date.now() * 0.001) * 0.04;
                    
                    // Subtle shoulder movement
                    if (player.leftArmGroup) {
                        player.leftArmGroup.rotation.x = breathAmount * 0.7;
                        player.leftArmGroup.rotation.z = breathAmount * 0.2;
                    }
                    if (player.rightArmGroup) {
                        player.rightArmGroup.rotation.x = breathAmount * 0.7;
                        player.rightArmGroup.rotation.z = -breathAmount * 0.2;
                    }
                    
                    // Occasional head movements to look around
                    if (state.idleTime > state.lastHeadMove + 3 + Math.random() * 5) {
                        state.headTargetRotation = {
                            x: (Math.random() - 0.5) * 0.5,
                            y: (Math.random() - 0.5) * 0.8
                        };
                        state.lastHeadMove = state.idleTime;
                        state.headMoveDuration = 0.5 + Math.random() * 0.5;
                        state.headMoveStart = state.idleTime;
                    }
                    
                    // Smooth head movement
                    if (state.headTargetRotation && state.idleTime < state.headMoveStart + state.headMoveDuration) {
                        const progress = (state.idleTime - state.headMoveStart) / state.headMoveDuration;
                        const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                        
                        if (player.headGroup) {
                            player.headGroup.rotation.x = breathAmount * 0.3 + state.headTargetRotation.x * easedProgress;
                            player.headGroup.rotation.y = state.headTargetRotation.y * easedProgress;
                        }
                    } else if (player.headGroup) {
                        // Return to neutral with breathing
                        player.headGroup.rotation.x = breathAmount * 0.3;
                        player.headGroup.rotation.y = 0;
                    }
                    
                    // Subtle weight shifting in legs
                    if (player.leftLegGroup) player.leftLegGroup.rotation.z = -Math.abs(breathAmount * 0.1);
                    if (player.rightLegGroup) player.rightLegGroup.rotation.z = Math.abs(breathAmount * 0.1);
                    
                    // Occasional blink with better timing
                    if (Math.random() < 0.007 && player.leftEyelid && player.rightEyelid) {
                        player.leftEyelid.scale.y = 0.2;
                        player.rightEyelid.scale.y = 0.2;
                        setTimeout(() => {
                            if (player.leftEyelid) player.leftEyelid.scale.y = 1;
                            if (player.rightEyelid) player.rightEyelid.scale.y = 1;
                        }, 150);
                    }
                }
                
                function walkingAnimation(delta) {
                    state.timeSinceLastStep += delta;
                    const walkCycle = Math.sin(state.timeSinceLastStep * 10);
                    const swingAmount = walkCycle * 0.8; // Increased from 0.5 to 0.8 for more noticeable movement
                    
                    // Arms swing opposite to legs - increased range
                    if (player.leftArmGroup) player.leftArmGroup.rotation.x = -swingAmount * 1.2;
                    if (player.rightArmGroup) player.rightArmGroup.rotation.x = swingAmount * 1.2;
                    
                    // Add subtle arm rotation around z-axis for more natural movement
                    if (player.leftArmGroup) player.leftArmGroup.rotation.z = Math.abs(swingAmount * 0.2);
                    if (player.rightArmGroup) player.rightArmGroup.rotation.z = -Math.abs(swingAmount * 0.2);
                    
                    // Add forearm movement with increased bend
                    if (player.leftForearmGroup) player.leftForearmGroup.rotation.x = -Math.abs(swingAmount * 0.8);
                    if (player.rightForearmGroup) player.rightForearmGroup.rotation.x = -Math.abs(swingAmount * 0.8);
                    
                    // Legs movement with increased range
                    if (player.leftLegGroup) player.leftLegGroup.rotation.x = swingAmount * 1.2;
                    if (player.rightLegGroup) player.rightLegGroup.rotation.x = -swingAmount * 1.2;
                    
                    // Add knee bend during walking - increased bend
                    if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = Math.abs(swingAmount * 1.0);
                    if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = Math.abs(swingAmount * 1.0);
                    
                    // Add torso twist for more natural walking
                    if (player.torso) {
                        player.torso.rotation.y = walkCycle * 0.1;
                    }
                    
                    // Add shoulder twist opposite to torso
                    if (player.shoulders) {
                        player.shoulders.rotation.y = -walkCycle * 0.15;
                    }
                    
                    // Add enhanced head bob with slight forward tilt using headGroup
                    if (player.headGroup) {
                        player.headGroup.position.y = 2.5 + Math.abs(walkCycle) * 0.08; // Apply bob to the group position
                        player.headGroup.rotation.x = Math.abs(walkCycle) * 0.15;
                        player.headGroup.rotation.y = -walkCycle * 0.1; // Head turns slightly opposite to torso
                    }
                    
                    // Add torso lean with more pronounced forward tilt when moving forward
                    const torsoLean = Math.abs(walkCycle) * 0.1;
                    if (moveForward) {
                        if (player.torso) player.torso.rotation.x = torsoLean;
                        if (player.headGroup) player.headGroup.rotation.x = torsoLean * 1.5;
                    }
                    
                    // Add slight bouncing effect to whole character
                    player.position.y = 1 + Math.abs(Math.sin(state.timeSinceLastStep * 20)) * 0.05;
                }
                
                function jumpingAnimation(delta) {
                    // Track jump phase
                    if (!state.jumpPhase) {
                        state.jumpPhase = "startup";
                        state.jumpTime = 0;
                    }
                    
                    state.jumpTime += delta;
                    
                    // Handle different jump phases with sequential animation
                    if (state.jumpPhase === "startup" && state.jumpTime < 0.15) {
                        // Initial crouch and arm preparation
                        const prepProgress = state.jumpTime / 0.15;
                        // Use easing function for smoother startup
                        const easeInProgress = prepProgress * prepProgress;
                        
                        // Crouch with smooth easing
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = 0.4 * easeInProgress;
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = 0.4 * easeInProgress;
                        
                        // Knees bent more with smooth easing
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = 0.6 * easeInProgress;
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = 0.6 * easeInProgress;
                        
                        // Arms start moving back and slightly outward
                        if (player.leftArmGroup) {
                            player.leftArmGroup.rotation.x = 0.3 * easeInProgress;
                            player.leftArmGroup.rotation.z = 0.1 * easeInProgress; // Move arm outward
                        }
                        if (player.rightArmGroup) {
                            player.rightArmGroup.rotation.x = 0.3 * easeInProgress;
                            player.rightArmGroup.rotation.z = -0.1 * easeInProgress; // Move arm outward
                        }
                    } 
                    else if (state.jumpPhase === "startup" && state.jumpTime >= 0.15) {
                        // Transition to upward phase
                        state.jumpPhase = "upward";
                        state.jumpTime = 0;
                    }
                    else if (state.jumpPhase === "upward" && state.jumpTime < 0.25) {
                        // Fast upward movement - extending legs, raising arms
                        const upProgress = state.jumpTime / 0.25;
                        const easeOut = 1 - Math.pow(1 - upProgress, 2); // Ease out
                        
                        // Legs straightening
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = 0.4 * (1 - easeOut);
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = 0.4 * (1 - easeOut);
                        
                        // Knees extending
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = 0.6 * (1 - easeOut);
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = 0.6 * (1 - easeOut);
                        
                        // Arms coming forward, up, and outward (higher and more spread than before)
                        if (player.leftArmGroup) {
                            player.leftArmGroup.rotation.x = 0.3 * (1 - easeOut) - 1.7 * easeOut; // Higher above head
                            player.leftArmGroup.rotation.z = 0.1 * (1 - easeOut) + 0.3 * easeOut; // More outward from body
                        }
                        if (player.rightArmGroup) {
                            player.rightArmGroup.rotation.x = 0.3 * (1 - easeOut) - 1.7 * easeOut; // Higher above head
                            player.rightArmGroup.rotation.z = -0.1 * (1 - easeOut) - 0.3 * easeOut; // More outward from body
                        }
                        
                        // Forearms bent for a more dynamic pose
                        if (player.leftForearmGroup) player.leftForearmGroup.rotation.x = -0.4 * easeOut;
                        if (player.rightForearmGroup) player.rightForearmGroup.rotation.x = -0.4 * easeOut;
                        
                        // Face expression - wider eyes, open mouth
                        if (player.leftEye) player.leftEye.scale.y = 1 + 0.3 * easeOut;
                        if (player.rightEye) player.rightEye.scale.y = 1 + 0.3 * easeOut;
                        if (player.mouth) player.mouth.scale.y = 1 + 1.5 * easeOut;
                    }
                    else if (state.jumpPhase === "upward" && state.jumpTime >= 0.25) {
                        // Transition to mid-air phase
                        state.jumpPhase = "midair";
                        state.midairStartTime = Date.now(); // Track when we entered midair for the wobble
                    }
                    else if (state.jumpPhase === "midair") {
                        // Calculate a smoother wobble motion that varies over time
                        const wobbleTime = (Date.now() - (state.midairStartTime || Date.now())) / 1000;
                        const airWobble = Math.sin(wobbleTime * 5) * 0.05;
                        
                        // Arms up above head, out to sides, and slightly waving
                        if (player.leftArmGroup) {
                            player.leftArmGroup.rotation.x = -1.7 + airWobble * 0.2; // Higher position
                            player.leftArmGroup.rotation.z = 0.3 + airWobble; // Spread out from torso
                        }
                        if (player.rightArmGroup) {
                            player.rightArmGroup.rotation.x = -1.7 - airWobble * 0.2; // Higher position
                            player.rightArmGroup.rotation.z = -0.3 - airWobble; // Spread out from torso
                        }
                        
                        // Forearms bent at a natural angle
                        if (player.leftForearmGroup) player.leftForearmGroup.rotation.x = -0.5 + airWobble * 0.3;
                        if (player.rightForearmGroup) player.rightForearmGroup.rotation.x = -0.5 - airWobble * 0.3;
                        
                        // Legs slightly spread and bent with subtle variation
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = 0.2 - airWobble * 0.7;
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = 0.2 + airWobble * 0.7;
                        
                        // Knees bent
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = 0.5 + airWobble * 0.1;
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = 0.5 - airWobble * 0.1;
                        
                        // Subtle torso rotation for more life-like motion
                        if (player.torso) {
                            player.torso.rotation.y = airWobble * 0.1;
                            player.torso.rotation.x = 0.1 + airWobble * 0.05;
                        }
                        
                        // Keep head straight instead of tilting down - REMOVED head tilting down
                        // Face expressions remain
                        if (player.leftEye) player.leftEye.scale.y = 1.3;
                        if (player.rightEye) player.rightEye.scale.y = 1.3;
                        if (player.mouth) player.mouth.scale.y = 2.5;
                    }
                    else if (state.jumpPhase === "landing" && state.jumpTime < 0.8) {
                        // Extended landing animation duration (from 0.5 to 0.8) for smoother transition
                        const landProgress = state.jumpTime / 0.8;
                        
                        // Use a custom easing function for more natural lowering motion
                        // Start fast, then slow down toward the end
                        const easeOutQuart = 1 - Math.pow(1 - landProgress, 4);
                        
                        // Arms coming down from above head with natural arc motion
                        if (player.leftArmGroup) {
                            // Multi-phase arm animation for more natural movement
                            if (landProgress < 0.6) {
                                // First phase: arms come down from above head (0-60% of animation)
                                const armPhaseDown = Math.min(1, landProgress / 0.6);
                                const armEasingDown = 1 - Math.pow(1 - armPhaseDown, 3); // Custom easing for arms
                                
                                // X rotation (arms lower from up to down with pendulum motion)
                                const pendulumSwing = Math.sin(armPhaseDown * Math.PI) * 0.3; // Swing effect
                                player.leftArmGroup.rotation.x = -1.7 * (1 - armEasingDown) + pendulumSwing;
                                
                                // Z rotation (arms move from out to in)
                                player.leftArmGroup.rotation.z = 0.3 * (1 - armEasingDown * 0.8);
                            } 
                            else {
                                // Second phase: arms settle into final position (60-100% of animation)
                                const armPhaseSettle = (landProgress - 0.6) / 0.4;
                                const armEasingSettle = 1 - Math.pow(1 - armPhaseSettle, 2);
                                
                                // Gentle dampening oscillation as arms reach rest position
                                const dampedOscillation = Math.sin(armPhaseSettle * Math.PI * 1.5) * 0.15 * (1 - armPhaseSettle);
                                player.leftArmGroup.rotation.x = dampedOscillation;
                                
                                // Z rotation continues to settle
                                player.leftArmGroup.rotation.z = 0.3 * (1 - 0.8) * (1 - armEasingSettle) + 
                                                               breathingEffect(dampedOscillation) * 0.1;
                            }
                        }
                        
                        if (player.rightArmGroup) {
                            // Mirror the left arm movements
                            if (landProgress < 0.6) {
                                // First phase
                                const armPhaseDown = Math.min(1, landProgress / 0.6);
                                const armEasingDown = 1 - Math.pow(1 - armPhaseDown, 3);
                                
                                const pendulumSwing = Math.sin(armPhaseDown * Math.PI) * 0.3;
                                player.rightArmGroup.rotation.x = -1.7 * (1 - armEasingDown) + pendulumSwing;
                                player.rightArmGroup.rotation.z = -0.3 * (1 - armEasingDown * 0.8);
                            } 
                            else {
                                // Second phase
                                const armPhaseSettle = (landProgress - 0.6) / 0.4;
                                const armEasingSettle = 1 - Math.pow(1 - armPhaseSettle, 2);
                                
                                const dampedOscillation = Math.sin(armPhaseSettle * Math.PI * 1.5) * 0.15 * (1 - armPhaseSettle);
                                player.rightArmGroup.rotation.x = dampedOscillation;
                                player.rightArmGroup.rotation.z = -0.3 * (1 - 0.8) * (1 - armEasingSettle) - 
                                                                breathingEffect(dampedOscillation) * 0.1;
                            }
                        }
                        
                        // Forearms relaxing with slight lag behind upper arms
                        if (player.leftForearmGroup) {
                            if (landProgress < 0.65) {
                                const forearmPhase = Math.max(0, Math.min(1, (landProgress - 0.05) / 0.6));
                                const forearmEase = 1 - Math.pow(1 - forearmPhase, 2);
                                player.leftForearmGroup.rotation.x = -0.5 * (1 - forearmEase);
                            } else {
                                // Add slight bend at the end for natural rest position
                                const finalBendPhase = (landProgress - 0.65) / 0.35;
                                const finalBendEase = 1 - Math.pow(1 - finalBendPhase, 2);
                                const restingBend = -0.1;
                                player.leftForearmGroup.rotation.x = restingBend * finalBendEase;
                            }
                        }
                        
                        if (player.rightForearmGroup) {
                            if (landProgress < 0.65) {
                                const forearmPhase = Math.max(0, Math.min(1, (landProgress - 0.05) / 0.6));
                                const forearmEase = 1 - Math.pow(1 - forearmPhase, 2);
                                player.rightForearmGroup.rotation.x = -0.5 * (1 - forearmEase);
                            } else {
                                const finalBendPhase = (landProgress - 0.65) / 0.35;
                                const finalBendEase = 1 - Math.pow(1 - finalBendPhase, 2);
                                const restingBend = -0.1;
                                player.rightForearmGroup.rotation.x = restingBend * finalBendEase;
                            }
                        }
                        
                        // Legs absorbing landing impact - initial bend followed by straightening
                        const kneeAbsorb = landProgress < 0.4 
                            ? Math.sin(landProgress * Math.PI / 0.8) * 0.7 // Rise to peak bend
                            : Math.sin(0.5 * Math.PI + (landProgress - 0.4) * Math.PI / 1.2) * 0.35 * (1 - (landProgress - 0.4) / 0.6); // Fall to straight
                        
                        if (player.leftLegGroup) player.leftLegGroup.rotation.x = kneeAbsorb;
                        if (player.rightLegGroup) player.rightLegGroup.rotation.x = kneeAbsorb;
                        
                        if (player.leftCalfGroup) player.leftCalfGroup.rotation.x = kneeAbsorb * 1.5;
                        if (player.rightCalfGroup) player.rightCalfGroup.rotation.x = kneeAbsorb * 1.5;
                        
                        // Torso slight forward lean then straightening
                        if (player.torso) {
                            if (landProgress < 0.5) {
                                player.torso.rotation.x = 0.15 * (1 - landProgress / 0.5);
                                player.torso.rotation.y = 0;
                            } else {
                                // Subtle torso balancing adjustment as it reaches equilibrium
                                const balancePhase = (landProgress - 0.5) / 0.5;
                                player.torso.rotation.x = Math.sin(balancePhase * Math.PI) * 0.05 * (1 - balancePhase);
                            }
                        }
                        
                        // Face returning to normal
                        if (player.leftEye) player.leftEye.scale.y = 1 + 0.3 * (1 - easeOutQuart);
                        if (player.rightEye) player.rightEye.scale.y = 1 + 0.3 * (1 - easeOutQuart);
                        if (player.mouth) player.mouth.scale.y = 1 + 1.5 * (1 - easeOutQuart);
                    }
                    
                    // Transition to landing when touching ground
                    if (canJump && state.jumpPhase === "midair") {
                        state.jumpPhase = "landing";
                        state.jumpTime = 0;
                    }
                    // Reset jump animation when landing animation completes
                    else if (canJump && state.jumpPhase === "landing" && state.jumpTime >= 0.8) {
                        state.jumpPhase = null;
                        state.landingComplete = true; // Mark landing as complete to transition to idle
                    }
                    // Reset jump animation when on ground (fallback)
                    else if (canJump && !state.jumpPhase) {
                        state.jumpPhase = null;
                        state.landingComplete = true;
                    }
                }
                
                // Helper function for subtle breathing effect
                function breathingEffect(input) {
                    return Math.sin(Date.now() * 0.001) * Math.max(0.5, Math.abs(input));
                }
                
                // Update 3rd person camera position
                function updateCamera() {
                    // Calculate camera position in orbit around player using spherical coordinates
                    const distance = state.cameraOffset.z;
                    
                    // Calculate position using spherical coordinates
                    const x = distance * Math.sin(state.cameraRotation.y) * Math.cos(state.cameraRotation.x);
                    const y = distance * Math.sin(state.cameraRotation.x);
                    const z = distance * Math.cos(state.cameraRotation.y) * Math.cos(state.cameraRotation.x);
                    
                    // Set camera position relative to player
                    camera.position.x = player.position.x - x;
                    camera.position.y = player.position.y + state.cameraOffset.y + y;
                    camera.position.z = player.position.z - z;
                    
                    // Always look at the player
                    const targetPosition = new THREE.Vector3(
                        player.position.x,
                        player.position.y + 2, // Head height
                        player.position.z
                    );
                    
                    camera.lookAt(targetPosition);
                    
                    // Update player rotation based on camera mode
                    if (state.cameraMode === 'shiftlock') {
                        // In shiftlock mode, player faces camera direction
                        player.rotation.y = state.cameraRotation.y;
                    }
                }
                
                // Game update function
                function update(time, delta) {
                    // Check if game is active (pointer is locked in shiftlock mode or we're in free mode)
                    if ((document.pointerLockElement === document.body || 
                         document.mozPointerLockElement === document.body || 
                         document.webkitPointerLockElement === document.body) || 
                        state.cameraMode === 'free') {
                        
                        // Apply gravity
                        state.playerVelocity.y -= state.gravity;
                        
                        // Calculate movement direction in player's local space
                        let xMove = 0;
                        let zMove = 0;
                        
                        if (moveForward) zMove += state.movementSpeed;
                        if (moveBackward) zMove -= state.movementSpeed;
                        if (moveLeft) xMove -= state.movementSpeed;
                        if (moveRight) xMove += state.movementSpeed;
                        
                        // Store original position for collision detection
                        const originalPosition = {
                            x: player.position.x,
                            z: player.position.z
                        };
                        
                        // Move player based on camera mode
                        if (xMove !== 0 || zMove !== 0) {
                            // Update last input time whenever there's movement
                            state.lastInputTime = time;
                            
                            if (state.cameraMode === 'shiftlock') {
                                // In shiftlock mode, move relative to camera/player direction
                                // Calculate normalized movement vector for consistent speed
                                const moveVector = new THREE.Vector3(xMove, 0, zMove);
                                const inputMagnitude = moveVector.length();
                                if (inputMagnitude > 0) {
                                    moveVector.normalize();
                                    // Use normalized vector and fixed movement speed to ensure consistent speed in all directions
                                    const shiftLockMoveAmount = state.movementSpeed;
                                    xMove = moveVector.x * shiftLockMoveAmount;
                                    zMove = moveVector.z * shiftLockMoveAmount;
                                }
                                
                                player.position.x += Math.sin(player.rotation.y) * zMove;
                                player.position.z += Math.cos(player.rotation.y) * zMove;
                                
                                player.position.x -= Math.cos(player.rotation.y) * xMove;
                                player.position.z += Math.sin(player.rotation.y) * xMove;
                            } else {
                                // In free mode, player always moves relative to its own facing direction
                                
                                // Calculate target rotation based on input direction
                                let targetRotationY = player.rotation.y;
                                
                                // Reset moving direction when input changes
                                if ((moveLeft && state.movingDirection === 'right') || 
                                    (moveRight && state.movingDirection === 'left') ||
                                    (moveForward && state.movingDirection === 'backward') ||
                                    (moveBackward && state.movingDirection === 'forward')) {
                                    state.movingDirection = null;
                                }
                                
                                // Determine movement direction based on camera view
                                let moveDirection = null;
                                if (moveLeft && !moveRight) {
                                    // Left relative to camera
                                    targetRotationY = state.cameraRotation.y + Math.PI/2;
                                    state.movingDirection = 'left';
                                    moveDirection = new THREE.Vector3(
                                        Math.cos(state.cameraRotation.y),
                                        0,
                                        -Math.sin(state.cameraRotation.y)
                                    );
                                } else if (moveRight && !moveLeft) {
                                    // Right relative to camera
                                    targetRotationY = state.cameraRotation.y - Math.PI/2;
                                    state.movingDirection = 'right';
                                    moveDirection = new THREE.Vector3(
                                        -Math.cos(state.cameraRotation.y),
                                        0,
                                        Math.sin(state.cameraRotation.y)
                                    );
                                } else if (moveForward && !moveBackward) {
                                    // Forward in camera direction
                                    targetRotationY = state.cameraRotation.y;
                                    state.movingDirection = 'forward';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y),
                                        0,
                                        Math.cos(state.cameraRotation.y)
                                    );
                                } else if (moveBackward && !moveForward) {
                                    // Backward from camera direction
                                    targetRotationY = state.cameraRotation.y + Math.PI;
                                    state.movingDirection = 'backward';
                                    moveDirection = new THREE.Vector3(
                                        -Math.sin(state.cameraRotation.y),
                                        0,
                                        -Math.cos(state.cameraRotation.y)
                                    );
                                }
                                
                                // Handle diagonal movement with better priority handling
                                if (moveForward && moveLeft && !moveRight && !moveBackward) {
                                    targetRotationY = state.cameraRotation.y + Math.PI/4;
                                    state.movingDirection = 'forwardLeft';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y + Math.PI/4),
                                        0,
                                        Math.cos(state.cameraRotation.y + Math.PI/4)
                                    );
                                } else if (moveForward && moveRight && !moveLeft && !moveBackward) {
                                    targetRotationY = state.cameraRotation.y - Math.PI/4;
                                    state.movingDirection = 'forwardRight';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y - Math.PI/4),
                                        0,
                                        Math.cos(state.cameraRotation.y - Math.PI/4)
                                    );
                                } else if (moveBackward && moveLeft && !moveRight && !moveForward) {
                                    targetRotationY = state.cameraRotation.y + Math.PI*3/4;
                                    state.movingDirection = 'backwardLeft';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y + Math.PI*3/4),
                                        0,
                                        Math.cos(state.cameraRotation.y + Math.PI*3/4)
                                    );
                                } else if (moveBackward && moveRight && !moveLeft && !moveForward) {
                                    targetRotationY = state.cameraRotation.y - Math.PI*3/4;
                                    state.movingDirection = 'backwardRight';
                                    moveDirection = new THREE.Vector3(
                                        Math.sin(state.cameraRotation.y - Math.PI*3/4),
                                        0,
                                        Math.cos(state.cameraRotation.y - Math.PI*3/4)
                                    );
                                }
                                
                                // Smoothly rotate player to face target direction
                                const turnSpeed = 3.0 * delta; // Reduced from 5.0 to 3.0 for smoother turning
                                const angleDiff = targetRotationY - player.rotation.y;
                                
                                // Normalize angle to [-PI, PI] for shortest rotation path
                                const normalizedAngleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                                
                                // Apply smooth rotation
                                if (Math.abs(normalizedAngleDiff) > 0.01) {
                                    player.rotation.y += normalizedAngleDiff * turnSpeed;
                                }
                                
                                // Move player based on input
                                let moveAmount = 0;
                                const moveVector = new THREE.Vector3(xMove, 0, zMove);
                                const inputMagnitude = moveVector.length();
                                
                                if (inputMagnitude > 0) {
                                    moveAmount = state.movementSpeed;
 
                                    // Move directly in the input direction without waiting for turning
                                    if (moveDirection) {
                                        // Normalize movement direction for consistent speed
                                        moveDirection.normalize();
                                        // Move directly in the input direction without waiting for turning
                                        player.position.x += moveDirection.x * moveAmount;
                                        player.position.z += moveDirection.z * moveAmount;
                                    }
                                }
                            }
                        } else {
                            // Reset moving direction when no movement keys are pressed
                            state.movingDirection = null;
                        }
                        
                        // Check for collisions with objects in the scene
                        if (xMove !== 0 || zMove !== 0) {
                            const isColliding = checkCollision(player);
                            
                            // If collision detected, revert to original position
                            if (isColliding) {
                                player.position.x = originalPosition.x;
                                player.position.z = originalPosition.z;
                            }
                            
                            // Check for story progression based on player position
                            checkStoryProgress(player.position);
                        }
                        
                        // Check if player is stuck and break free if needed
                        checkIfStuck(time, player);
                        
                        // Auto-align camera with character direction after delay
                        if (state.cameraMode === 'free' && !state.rightMouseDown) {
                            const timeSinceLastInput = (time / 1000) - state.lastInputTime;
                            if (timeSinceLastInput > state.autoAlignDelay && !moveForward && !moveBackward && !moveLeft && !moveRight) {
                                // Gradually align camera with character direction
                                const angleDiff = player.rotation.y - state.cameraRotation.y;
                                // Normalize angle to [-PI, PI]
                                const normalizedAngleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                                
                                // Apply smooth rotation at a slower pace for more natural feeling
                                state.cameraRotation.y += normalizedAngleDiff * delta * 0.8;
                            }
                        }
                        
                        // Apply jumping - only jump if space is pressed, can jump, and space was released since last jump
                        if (state.keysPressed['Space'] && canJump && state.spaceKeyReleased) {
                            state.playerVelocity.y = state.jumpForce;
                            canJump = false;
                            state.spaceKeyReleased = false; // Mark that space has been used for jumping
                            
                            // Reset jump animation with correct phase
                            state.jumpPhase = "startup";
                            state.jumpTime = 0;
                            state.landingComplete = false;
                        }
                        
                        // Apply vertical movement (jumping/falling)
                        player.position.y += state.playerVelocity.y;
                        
                        // Ground collision
                        if (player.position.y < 1) {
                            player.position.y = 1;
                            state.playerVelocity.y = 0;
                            canJump = true;
                        }
                        
                        // Keep player within bounds
                        const boundary = 250; // Increased to match the larger outside environment
                        if (player.position.x > boundary) player.position.x = boundary;
                        if (player.position.x < -boundary) player.position.x = -boundary;
                        if (player.position.z > boundary) player.position.z = boundary;
                        if (player.position.z < -boundary) player.position.z = -boundary;
                        
                        // Update camera position
                        updateCamera();
                        
                        // Animate character
                        animateCharacter(delta);
                        
                        debugElement.textContent = `Position: x=${player.position.x.toFixed(2)}, y=${player.position.y.toFixed(2)}, z=${player.position.z.toFixed(2)}`;
                    }
                }
                
                // Collision detection function
                function checkCollision(player) {
                    // Create raycasters in multiple directions
                    const directions = [
                        new THREE.Vector3(1, 0, 0),   // Right
                        new THREE.Vector3(-1, 0, 0),  // Left
                        new THREE.Vector3(0, 0, 1),   // Forward
                        new THREE.Vector3(0, 0, -1),  // Backward
                        new THREE.Vector3(1, 0, 1).normalize(),   // Forward-Right
                        new THREE.Vector3(-1, 0, 1).normalize(),  // Forward-Left
                        new THREE.Vector3(1, 0, -1).normalize(),  // Backward-Right
                        new THREE.Vector3(-1, 0, -1).normalize(), // Backward-Left
                    ];
                    
                    // Reduced player radius to prevent getting stuck
                    const playerRadius = 0.5; // Reduced from 0.7
                    
                    // Slightly elevated position to avoid ground collision issues
                    const playerPosition = new THREE.Vector3(
                        player.position.x,
                        player.position.y + 1.2, // Slightly higher to avoid false positives
                        player.position.z
                    );
                    
                    // Check for collisions in each direction
                    for (const direction of directions) {
                        const raycaster = new THREE.Raycaster(playerPosition, direction, 0, playerRadius);
                        const intersects = raycaster.intersectObjects(scene.children, true);
                        
                        // Filter out non-collidable objects (like the player itself)
                        const collidableIntersects = intersects.filter(intersection => {
                            // Skip player mesh and non-collidable objects
                            const obj = intersection.object;
                            
                            // Skip if it's part of the player model
                            if (obj === player || (obj.parent && (obj.parent === player || obj.parent.parent === player))) {
                                return false;
                            }
                            
                            // Skip fog by checking for transparent materials with low opacity
                            if (obj.material && obj.material.transparent && obj.material.opacity < 0.3) {
                                return false;
                            }
                            
                            // Check for explicitly marked collidable objects
                            const isCollidable = obj.userData && obj.userData.collidable === true;
                            
                            // Skip objects that are too close to the floor
                            const isFloorLike = intersection.point.y < 0.3;
                            
                            return isCollidable && !isFloorLike;
                        });
                        
                        if (collidableIntersects.length > 0) {
                            // Log collision details
                            const hitObject = collidableIntersects[0].object;
                            if (hitObject && hitObject.userData.debugged !== true) {
                                console.log("Collision with:", hitObject);
                                hitObject.userData.debugged = true; // Only log once per object
                            }
                            return true; // Collision detected
                        }
                    }
                    
                    return false; // No collision
                }

                // Add a break-free function to prevent getting completely stuck
                let stuckCheckTimer = 0;
                let lastPlayerPosition = new THREE.Vector3();
                let stuckTime = 0;
                
                // Add this to the update function to prevent permanent sticking
                function checkIfStuck(time, playerObj) {
                    // Only check every second
                    if (time - stuckCheckTimer < 1000) return false;
                    stuckCheckTimer = time;
                    
                    // Check if position has changed
                    const currentPos = new THREE.Vector3(playerObj.position.x, 0, playerObj.position.z);
                    const distance = currentPos.distanceTo(lastPlayerPosition);
                    
                    // If barely moved for 3 seconds while movement keys are pressed
                    const moveForward = state.keysPressed['KeyW'] || false;
                    const moveBackward = state.keysPressed['KeyS'] || false;
                    const moveLeft = state.keysPressed['KeyA'] || false;
                    const moveRight = state.keysPressed['KeyD'] || false;
                    const tryingToMove = moveForward || moveBackward || moveLeft || moveRight;
                    
                    if (distance < 0.1 && tryingToMove) {
                        stuckTime += 1;
                        if (stuckTime >= 3) {
                            // Break free by moving the player up slightly
                            playerObj.position.y += 0.2;
                            stuckTime = 0;
                            console.log("Breaking free from stuck position");
                            return true;
                        }
                    } else {
                        stuckTime = 0;
                    }
                    
                    // Update last position
                    lastPlayerPosition.copy(currentPos);
                    return false;
                }

                // Animation loop with delta time
                // Global cutscene variables - Setting to inactive but keeping for compatibility
                let cutsceneActive = false; // Permanently disabled // Always false to prevent cutscene activation
                let cutsceneStep = 0;
                let cutsceneTimer = 0;
                let dialogueBox = null;
                let skipButton = null;
                
                // Game progression variables - Set to escape phase directly 
                let gameProgress = {
                    hasBackpack: true, // Player has backpack in sneak scenario
                    storyPhase: 'escape', // Directly set to escape phase to skip intro
                    checkpointTriggered: false,
                    borderReached: false
                };
                
                let lastFrameTime = 0;
                function animate(time) {
    requestAnimationFrame(animate);
    
    try {
                    
                    // Skip updating game state if paused
                    if (state.gamePaused) {
                        renderer.render(scene, camera);
                        return;
                    }
                    
                    const delta = (time - lastFrameTime) / 1000;
                    lastFrameTime = time;
                    
                    // Always update player movement since cutscene is disabled
                    update(time, delta);
                    // Check story progress based on player position
                    checkStoryProgress(player.position);
                    
                    // Animate flickering lights if they exist
                    if (window.flickeringLights) {
                        window.flickeringLights.forEach(light => {
                            const { flickerSpeed, flickerIntensity, baseIntensity, timeOffset } = light.userData;
                            
                            // Create organic flickering pattern
                            const flicker = Math.sin(time * flickerSpeed + timeOffset) * 0.5 + 0.5;
                            const noise = Math.random() * 0.2;
                            
                            light.intensity = baseIntensity * (1 - flickerIntensity * 0.8) + 
                                              flickerIntensity * baseIntensity * (flicker + noise);
                        });
                    }
                    
                    // Render the scene
                    renderer.render(scene, camera);
                    } catch (err) {
        console.error("Animation error in shadows.html:", err);
        document.getElementById("debug").textContent = "Error: " + err.message;
    }
}
                
                animate(0);
                
                debugElement.textContent = "Game running - click to start!";
                
                // Initialize inventory system
                initInventorySystem();
                
                // Interior walls to create rooms
                // Living room wall (separating from dining room)
                const livingRoomWall = createWallSection(
                    20,
                    frontWallHeight,
                    houseDimensions.wallThickness,
                    -5,
                    frontWallHeight / 2,
                    houseDimensions.length / 4,
                    materials.wallInterior
                );
                // House element removed
                
                // Doorway in living room wall
                const livingRoomDoorway = createWallSection(
                    4,
                    8,
                    houseDimensions.wallThickness,
                    5,
                    4,
                    houseDimensions.length / 4,
                    materials.wallInterior
                );
                // Remove the doorway (creating a hole in the wall)
                // Instead of adding, we just don't add this mesh
                
                // Kitchen wall (perpendicular to living room wall)
                const kitchenWall = createWallSection(
                    houseDimensions.wallThickness,
                    frontWallHeight,
                    20,
                    5,
                    frontWallHeight / 2,
                    houseDimensions.length / 8,
                    materials.wallInterior
                );
                // House element removed
                
                // Bedroom divider wall
                const bedroomWall = createWallSection(
                    houseDimensions.wallThickness,
                    frontWallHeight,
                    25,
                    -10,
                    frontWallHeight / 2,
                    -houseDimensions.length / 4,
                    materials.wallInterior
                );
                // House element removed
                
                // Bathroom wall
                const bathroomWall = createWallSection(
                    15,
                    frontWallHeight,
                    houseDimensions.wallThickness,
                    10,
                    frontWallHeight / 2,
                    -houseDimensions.length / 3,
                    materials.wallInterior
                );
                // House element removed
                
                // Add furniture to different rooms
                
                // Living Room Furniture
                const livingRoomGroup = new THREE.Group();
                // Moved the entire living room group to ensure it's properly positioned
                livingRoomGroup.position.set(0, 0, 5); // Changed z from 10 to 5
                // House element removed
                
                // Couch
                function createCouch() {
                    const couchGroup = new THREE.Group();
                    
                    // Couch base
                    const couchBase = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 1.5, 3.5),
                        materials.fabric
                    );
                    couchBase.position.set(0, 0.75, 0);
                    couchBase.castShadow = true;
                    couchBase.receiveShadow = true;
                    couchGroup.add(couchBase);
                    
                    // Couch back
                    const couchBack = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 3, 1),
                        materials.fabric
                    );
                    couchBack.position.set(0, 2.25, -1.75);
                    couchBack.castShadow = true;
                    couchBack.receiveShadow = true;
                    couchGroup.add(couchBack);
                    
                    // Couch arms
                    const leftArm = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 2.5, 3.5),
                        materials.fabric
                    );
                    leftArm.position.set(-5.5, 1.25, 0);
                    leftArm.castShadow = true;
                    leftArm.receiveShadow = true;
                    couchGroup.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 2.5, 3.5),
                        materials.fabric
                    );
                    rightArm.position.set(5.5, 1.25, 0);
                    rightArm.castShadow = true;
                    rightArm.receiveShadow = true;
                    couchGroup.add(rightArm);
                    
                    // Cushions
                    for (let i = 0; i < 3; i++) {
                        const cushion = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.7, 3),
                            materials.fabricDark
                        );
                        cushion.position.set(-3.5 + i * 3.5, 1.8, 0);
                        cushion.castShadow = true;
                        cushion.receiveShadow = true;
                        couchGroup.add(cushion);
                    }
                    
                    return couchGroup;
                }
                
                const couch = createCouch();
                // Moved couch to be in a better position
                couch.position.set(-2, 0, 0); // Changed x from -5 to -2
                couch.rotation.y = -Math.PI / 2;
                livingRoomGroup.add(couch);
                
                // Coffee table
                const coffeeTable = new THREE.Group();
                
                // Table top
                const tableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 0.5, 4),
                    materials.woodDark
                );
                tableTop.position.set(0, 1.5, 0);
                tableTop.castShadow = true;
                tableTop.receiveShadow = true;
                coffeeTable.add(tableTop);
                
                // Table legs
                for (let x = -1; x <= 1; x += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        const leg = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 1.5, 0.5),
                            materials.woodDark
                        );
                        leg.position.set(x * 2.5, 0.75, z * 1.5);
                        leg.castShadow = true;
                        leg.receiveShadow = true;
                        coffeeTable.add(leg);
                    }
                }
                
                coffeeTable.position.set(2, 0, 0); // Changed from (0, 0, 5) to (2, 0, 0)
                livingRoomGroup.add(coffeeTable);
                
                // TV Stand with TV
                const tvStand = new THREE.Group();
                
                // Stand base
                const standBase = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 2, 2),
                    materials.woodMedium
                );
                standBase.position.set(0, 1, 0);
                standBase.castShadow = true;
                standBase.receiveShadow = true;
                tvStand.add(standBase);
                
                // TV
                const tv = new THREE.Mesh(
                    new THREE.BoxGeometry(7, 4, 0.5),
                    materials.metal
                );
                tv.position.set(0, 4, 0);
                tv.castShadow = true;
                tv.receiveShadow = true;
                tvStand.add(tv);
                
                // TV screen
                const tvScreen = new THREE.Mesh(
                    new THREE.PlaneGeometry(6.5, 3.6),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                tvScreen.position.set(0, 4, 0.26);
                tvStand.add(tvScreen);
                
                tvStand.position.set(8, 0, 0); // Changed from (10, 0, 5) to (8, 0, 0)
                tvStand.rotation.y = Math.PI / 2;
                livingRoomGroup.add(tvStand);
                
                // Armchair
                function createArmchair() {
                    const chairGroup = new THREE.Group();
                    
                    // Chair base
                    const chairBase = new THREE.Mesh(
                        new THREE.BoxGeometry(3.5, 1.5, 3.5),
                        materials.fabricDark
                    );
                    chairBase.position.set(0, 0.75, 0);
                    chairBase.castShadow = true;
                    chairBase.receiveShadow = true;
                    chairGroup.add(chairBase);
                    
                    // Chair back
                    const chairBack = new THREE.Mesh(
                        new THREE.BoxGeometry(3.5, 3, 1),
                        materials.fabricDark
                    );
                    chairBack.position.set(0, 2.25, -1.75);
                    chairBack.castShadow = true;
                    chairBack.receiveShadow = true;
                    chairGroup.add(chairBack);
                    
                    // Chair arms
                    const leftArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 1.8, 3.5),
                        materials.fabricDark
                    );
                    leftArm.position.set(-1.85, 1.4, 0);
                    leftArm.castShadow = true;
                    leftArm.receiveShadow = true;
                    chairGroup.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 1.8, 3.5),
                        materials.fabricDark
                    );
                    rightArm.position.set(1.85, 1.4, 0);
                    rightArm.castShadow = true;
                    rightArm.receiveShadow = true;
                    chairGroup.add(rightArm);
                    
                    // Cushion
                    const cushion = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.7, 3),
                        materials.fabric
                    );
                    cushion.position.set(0, 1.8, 0);
                    cushion.castShadow = true;
                    cushion.receiveShadow = true;
                    chairGroup.add(cushion);
                    
                    return chairGroup;
                }
                
                const armchair1 = createArmchair();
                armchair1.position.set(2, 0, 8); // Changed from (5, 0, 15) to (2, 0, 8)
                armchair1.rotation.y = -Math.PI / 4;
                livingRoomGroup.add(armchair1);
                
                const armchair2 = createArmchair();
                armchair2.position.set(-2, 0, 8); // Changed from (-5, 0, 15) to (-2, 0, 8)
                armchair2.rotation.y = Math.PI / 4;
                livingRoomGroup.add(armchair2);
                
                // Dining Room and Kitchen
                const diningRoomGroup = new THREE.Group();
                // Adjust position so it's more centered in the dining area and away from walls
                // Moving it a bit toward the center to avoid wall intersections
                diningRoomGroup.position.set(15, 0, 10); // Changed from z=15 to z=10
                // House element removed
                
                // Dining table
                const diningTable = new THREE.Group();
                
                // Table top
                const diningTableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 0.5, 5),
                    materials.woodMedium
                );
                diningTableTop.position.set(0, 3, 0);
                diningTableTop.castShadow = true;
                diningTableTop.receiveShadow = true;
                diningTable.add(diningTableTop);
                
                // Table legs
                for (let x = -1; x <= 1; x += 2) {
                    for (let z = -1; z <= 1; z += 2) {
                        const leg = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 3, 8),
                            materials.woodMedium
                        );
                        leg.position.set(x * 3.5, 1.5, z * 2);
                        leg.castShadow = true;
                        leg.receiveShadow = true;
                        diningTable.add(leg);
                    }
                }
                
                diningTable.position.set(0, 0, 0);
                diningRoomGroup.add(diningTable);
                
                // Dining chairs
                function createDiningChair() {
                    const chairGroup = new THREE.Group();
                    
                    // Seat
                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.3, 1.8),
                        materials.woodMedium
                    );
                    seat.position.set(0, 1.8, 0);
                    seat.castShadow = true;
                    seat.receiveShadow = true;
                    chairGroup.add(seat);
                    
                    // Back
                    const back = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 2, 0.3),
                        materials.woodMedium
                    );
                    back.position.set(0, 2.9, -0.9);
                    back.castShadow = true;
                    back.receiveShadow = true;
                    chairGroup.add(back);
                    
                    // Legs
                    for (let x = -0.7; x <= 0.7; x += 1.4) {
                        for (let z = -0.7; z <= 0.7; z += 1.4) {
                            const leg = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.1, 0.1, 1.8, 8),
                                materials.woodMedium
                            );
                            leg.position.set(x, 0.9, z);
                            leg.castShadow = true;
                            leg.receiveShadow = true;
                            chairGroup.add(leg);
                        }
                    }
                    
                    return chairGroup;
                }
                
                // Place chairs around the table
                const chairPositions = [
                    { x: 0, z: -3, rotation: 0 },
                    { x: 0, z: 3, rotation: Math.PI },
                    { x: -4, z: 0, rotation: Math.PI / 2 },
                    { x: 4, z: 0, rotation: -Math.PI / 2 },
                ];
                
                chairPositions.forEach(pos => {
                    const chair = createDiningChair();
                    chair.position.set(pos.x, 0, pos.z);
                    chair.rotation.y = pos.rotation;
                    diningRoomGroup.add(chair);
                });
                
                // Kitchen Area
                const kitchenGroup = new THREE.Group();
                // Moved kitchen closer to center to avoid wall collisions
                kitchenGroup.position.set(12, 0, 0); // Changed from x=15 to x=12
                // House element removed
                
                // Kitchen counter (L-shaped)
                const counterMaterial = materials.woodLight;
                const counterTopMaterial = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, roughness: 0.4, metalness: 0.3 });
                
                // Base cabinets - moved slightly so they don't overlap with walls
                const counterBaseGeom = new THREE.BoxGeometry(10, 3, 2); // Reduced width from 12 to 10
                const counterBase = new THREE.Mesh(counterBaseGeom, counterMaterial);
                counterBase.position.set(0, 1.5, -7); // Changed z from -8 to -7
                counterBase.castShadow = true;
                counterBase.receiveShadow = true;
                kitchenGroup.add(counterBase);
                
                const counterBaseL = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 3, 6), // Reduced length from 8 to 6
                    counterMaterial
                );
                counterBaseL.position.set(-5, 1.5, -4); // Changed x from -6 to -5
                counterBaseL.castShadow = true;
                counterBaseL.receiveShadow = true;
                kitchenGroup.add(counterBaseL);
                
                // Counter tops - adjusted to match base cabinet changes
                const counterTop = new THREE.Mesh(
                    new THREE.BoxGeometry(10.4, 0.3, 2.4), // Reduced width from 12.4 to 10.4
                    counterTopMaterial
                );
                counterTop.position.set(0, 3.15, -7); // Changed z from -8 to -7
                counterTop.castShadow = true;
                counterTop.receiveShadow = true;
                kitchenGroup.add(counterTop);
                
                const counterTopL = new THREE.Mesh(
                    new THREE.BoxGeometry(2.4, 0.3, 6), // Reduced length from 8 to 6
                    counterTopMaterial
                );
                counterTopL.position.set(-5, 3.15, -4); // Changed x from -6 to -5
                counterTopL.castShadow = true;
                counterTopL.receiveShadow = true;
                kitchenGroup.add(counterTopL);
                
                // Sink
                const sink = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.1, 1.5),
                    materials.metal
                );
                sink.position.set(3, 3.2, -7); // Changed z from -8 to -7
                kitchenGroup.add(sink);
                
                // Stove
                const stove = new THREE.Group();
                const stoveBase = new THREE.Mesh(
                    new THREE.BoxGeometry(2.2, 0.1, 1.8),
                    materials.metal
                );
                stoveBase.position.set(-3, 3.2, -7); // Changed z from -8 to -7
                stove.add(stoveBase);
                
                // Burners
                for (let x = -0.6; x <= 0.6; x += 1.2) {
                    for (let z = -0.5; z <= 0.5; z += 1) {
                        const burner = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16),
                            new THREE.MeshStandardMaterial({ color: 0x333333 })
                        );
                        burner.position.set(x, 0.075, z);
                        burner.rotation.x = Math.PI / 2;
                        stove.add(burner);
                    }
                }
                
                stove.position.set(-3, 3.2, -7); // Changed z from -8 to -7
                kitchenGroup.add(stove);
                
                // Refrigerator
                const fridge = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 7, 2.5), // Reduced depth from 3 to 2.5
                    materials.metal
                );
                fridge.position.set(-5, 3.5, 0); // Changed x from -6 to -5
                fridge.castShadow = true;
                fridge.receiveShadow = true;
                kitchenGroup.add(fridge);
                
                // Fridge details
                const fridgeDoor = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.8, 6.8),
                    new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
                );
                fridgeDoor.position.set(0, 0, 1.51);
                fridge.add(fridgeDoor);
                
                const fridgeHandle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 2, 8),
                    materials.metal
                );
                fridgeHandle.position.set(-1.2, 0, 1.6);
                fridgeHandle.rotation.z = Math.PI / 2;
                fridge.add(fridgeHandle);
                
                // Bedroom
                const bedroomGroup = new THREE.Group();
                // Adjusted bedroom position to be more centered in the room
                bedroomGroup.position.set(-12, 0, -15); // Changed from (-15, 0, -20) to (-12, 0, -15)
                // House element removed
                
                // Bed
                const bed = new THREE.Group();
                
                // Bed frame
                const bedFrame = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 1, 10),
                    materials.woodDark
                );
                bedFrame.position.set(0, 0.5, 0);
                bedFrame.castShadow = true;
                bedFrame.receiveShadow = true;
                bed.add(bedFrame);
                
                // Mattress
                const mattress = new THREE.Mesh(
                    new THREE.BoxGeometry(7.5, 1, 9.5),
                    new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.7 })
                );
                mattress.position.set(0, 1.5, 0);
                mattress.castShadow = true;
                mattress.receiveShadow = true;
                bed.add(mattress);
                
                // Pillows
                for (let i = -1; i <= 1; i+=2) {
                    const pillow = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 0.8, 2),
                        new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.7 })
                    );
                    pillow.position.set(i*2, 2, -3.5);
                    pillow.castShadow = true;
                    pillow.receiveShadow = true;
                    bed.add(pillow);
                }
                
                // Blanket
                const blanket = new THREE.Mesh(
                    new THREE.BoxGeometry(7.5, 0.3, 5),
                    materials.fabric
                );
                blanket.position.set(0, 2, 2);
                blanket.castShadow = true;
                blanket.receiveShadow = true;
                bed.add(blanket);
                
                // Headboard
                const headboard = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 4, 0.5),
                    materials.woodDark
                );
                headboard.position.set(0, 2.5, -5);
                headboard.castShadow = true;
                headboard.receiveShadow = true;
                bed.add(headboard);
                
                bed.rotation.y = Math.PI / 2;
                bedroomGroup.add(bed);
                
                // Bedside table
                const bedsideTable = new THREE.Group();
                
                // Table top
                const bedsideTableTop = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.5, 2),
                    materials.woodDark
                );
                bedsideTableTop.position.set(0, 2, 0);
                bedsideTableTop.castShadow = true;
                bedsideTableTop.receiveShadow = true;
                bedsideTable.add(bedsideTableTop);
                
                // Table body
                const bedsideTableBody = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 2, 1.8),
                    materials.woodDark
                );
                bedsideTableBody.position.set(0, 1, 0);
                bedsideTableBody.castShadow = true;
                bedsideTableBody.receiveShadow = true;
                bedsideTable.add(bedsideTableBody);
                
                // Lamp on bedside table
                const lamp = new THREE.Group();
                
                // Lamp base
                const lampBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 0.2, 16),
                    materials.metal
                );
                lampBase.position.set(0, 0, 0);
                lampBase.castShadow = true;
                lampBase.receiveShadow = true;
                lamp.add(lampBase);
                
                // Lamp post
                const lampPost = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8),
                    materials.metal
                );
                lampPost.position.set(0, 0.6, 0);
                lampPost.castShadow = true;
                lampPost.receiveShadow = true;
                lamp.add(lampPost);
                
                // Lamp shade
                const lampShade = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.8, 0.7, 16, 1, true),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffffee, 
                        roughness: 0.5, 
                        emissive: 0xffffaa,
                        emissiveIntensity: 0.30 
                    })
                );
                lampShade.position.set(0, 1.2, 0);
                lampShade.castShadow = true;
                lamp.add(lampShade);
                
                // Lamp light
                const lampLight = new THREE.PointLight(0xffffaa, 0.8, 10);
                lampLight.position.set(0, 1.2, 0);
                lampLight.castShadow = true;
                lamp.add(lampLight);
                
                lamp.position.set(0, 2.25, 0);
                bedsideTable.add(lamp);
                
                bedsideTable.position.set(4, 0, 4); // Changed from (5, 0, 5) to (4, 0, 4)
                bedroomGroup.add(bedsideTable);
                
                // Wardrobe
                const wardrobe = new THREE.Group();
                
                // Wardrobe body
                const wardrobeBody = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 8, 1.5), // Reduced dimensions from (6, 8, 2) to (5, 8, 1.5)
                    materials.woodMedium
                );
                wardrobeBody.position.set(0, 4, 0);
                wardrobeBody.castShadow = true;
                wardrobeBody.receiveShadow = true;
                wardrobe.add(wardrobeBody);
                
                // Wardrobe doors
                for (let i = -1; i <= 1; i+=2) {
                    const door = new THREE.Mesh(
                        new THREE.BoxGeometry(2.4, 7.8, 0.2), // Adjusted width from 2.9 to 2.4
                        materials.woodLight
                    );
                    door.position.set(i*1.25, 4, 0.85); // Adjusted x from i*1.5 to i*1.25 and z from 1 to 0.85
                    door.castShadow = true;
                    door.receiveShadow = true;
                    wardrobe.add(door);
                    
                    // Door handle
                    const handle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8),
                        materials.metal
                    );
                    handle.position.set(i*0.8, 4, 0.95); // Adjusted x from i*1 to i*0.8 and z from 1.1 to 0.95
                    handle.rotation.z = Math.PI / 2;
                    wardrobe.add(handle);
                }
                
                wardrobe.position.set(-5, 0, -4); // Changed from (-5, 0, -5) to (-5, 0, -4)
                bedroomGroup.add(wardrobe);
                
                // Bathroom
                const bathroomGroup = new THREE.Group();
                // Adjusted bathroom position to avoid wall intersections
                bathroomGroup.position.set(15, 0, -15); // Changed z from -20 to -15
                // House element removed
                
                // Toilet
                const toilet = new THREE.Group();
                
                // Base
                const toiletBase = new THREE.Mesh(
                    new THREE.BoxGeometry(1.5, 0.5, 2),
                    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 })
                );
                toiletBase.position.set(0, 0.25, 0);
                toiletBase.castShadow = true;
                toiletBase.receiveShadow = true;
                toilet.add(toiletBase);
                
                // Bowl
                const toiletBowl = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.6, 0.5, 0.5, 16),
                    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 })
                );
                toiletBowl.position.set(0, 0.5, 0);
                toilet.add(toiletBowl);
                
                // Tank
                const toiletTank = new THREE.Mesh(
                    new THREE.BoxGeometry(1.4, 2, 0.8),
                    new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 })
                );
                toiletTank.position.set(0, 1.5, -0.9);
                toiletTank.castShadow = true;
                toiletTank.receiveShadow = true;
                toilet.add(toiletTank);
                
                // Seat
                const toiletSeat = new THREE.Mesh(
                    new THREE.TorusGeometry(0.6, 0.2, 16, 32, Math.PI),
                    new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.5 })
                );
                toiletSeat.position.set(0, 0.7, 0);
                toiletSeat.rotation.x = Math.PI / 2;
                toiletSeat.rotation.z = Math.PI;
                toilet.add(toiletSeat);
                
                toilet.position.set(3, 0, -3); // Changed from (5, 0, -5) to (3, 0, -3)
                toilet.rotation.y = Math.PI;
                bathroomGroup.add(toilet);
                
                // Lighting for the entire house
                // Living room light
                const livingRoomLight = new THREE.PointLight(0xffffcc, 0.8, 40);
                livingRoomLight.position.set(0, houseDimensions.height - 1, 5); // Changed z from 10 to 5
                livingRoomLight.castShadow = true;
                livingRoomLight.shadow.mapSize.width = 1024;
                livingRoomLight.shadow.mapSize.height = 1024;
                // House element removed
                
                // Kitchen light
                const kitchenLight = new THREE.PointLight(0xffffcc, 0.8, 30);
                kitchenLight.position.set(12, houseDimensions.height - 1, 0); // Changed x from 15 to 12
                kitchenLight.castShadow = true;
                kitchenLight.shadow.mapSize.width = 1024;
                kitchenLight.shadow.mapSize.height = 1024;
                // House element removed
                
                // Dining room light
                const diningRoomLight = new THREE.PointLight(0xffffcc, 0.8, 30);
                diningRoomLight.position.set(15, houseDimensions.height - 1, 10); // Changed z from 15 to 10
                diningRoomLight.castShadow = true;
                diningRoomLight.shadow.mapSize.width = 1024;
                diningRoomLight.shadow.mapSize.height = 1024;
                // House element removed
                
                // Bedroom light
                const bedroomLight = new THREE.PointLight(0xffffcc, 0.8, 30);
                bedroomLight.position.set(-12, houseDimensions.height - 1, -15); // Changed from (-15, 0, -20) to (-12, 0, -15)
                bedroomLight.castShadow = true;
                bedroomLight.shadow.mapSize.width = 1024;
                bedroomLight.shadow.mapSize.height = 1024;
                // House element removed
                
                // Bathroom light
                const bathroomLight = new THREE.PointLight(0xffffcc, 0.8, 20);
                bathroomLight.position.set(15, houseDimensions.height - 1, -15); // Changed z from -20 to -15
                bathroomLight.castShadow = true;
                bathroomLight.shadow.mapSize.width = 1024;
                bathroomLight.shadow.mapSize.height = 1024;
                // House element removed

                // Initialize audio effects
                function initAudioEffects() {
                    // Set up ambient sounds
                    const ambientWind = document.getElementById('ambient-wind');
                    
                    // Set volume
                    ambientWind.volume = 0.3;
                    ambientWind.loop = false; // Ensure it doesn't loop
                    
                    // Don't start playing on first click
                    // We'll play it only when the cutscene starts
                }

                // Create array to store all collidable objects
                const collidableObjects = [];
                
                // Function to add an object to collidable list
                function addToCollidables(object) {
                    // If it's a mesh, add it directly
                    if (object.isMesh) {
                        collidableObjects.push(object);
                    }
                    
                    // If it's a group, add all its children recursively
                    if (object.children && object.children.length > 0) {
                        object.children.forEach(child => {
                            if (child.isMesh) {
                                collidableObjects.push(child);
                            } else if (child.children && child.children.length > 0) {
                                addToCollidables(child);
                            }
                        });
                    }
                }
                
                // Add walls and furniture to collidable objects
                addToCollidables(houseGroup);
                
                // Add trees and other outside objects to collidables
                scene.children.forEach(child => {
                    if (child.name === 'outsideGroup' || child.userData.collidable) {
                        addToCollidables(child);
                    }
                });
                
                // Mark all objects in the outsideGroup as collidable
                function markOutsideObjectsAsCollidable() {
                    const outsideGroup = scene.getObjectByName('outsideGroup');
                    if (outsideGroup) {
                        outsideGroup.traverse(function(object) {
                            if (object.isMesh) {
                                // Skip fog-like objects based on material properties
                                if (object.material && object.material.transparent && object.material.opacity < 0.3) {
                                    console.log("Skipping fog-like transparent object - not collidable");
                                    return;
                                }
                                
                                object.userData.collidable = true;
                                collidableObjects.push(object);
                            }
                        });
                        console.log("Marked outside objects as collidable (except fog-like objects)");
                    }
                }
                
                // Create dialogue UI elements
                function createDialogueUI() {
                    // Create dialogue box if it doesn't exist
                    if (!dialogueBox) {
                        dialogueBox = document.createElement('div');
                        dialogueBox.id = 'dialogue-box';
                        dialogueBox.style.position = 'absolute';
                        dialogueBox.style.bottom = '50px';
                        dialogueBox.style.left = '50%';
                        dialogueBox.style.transform = 'translateX(-50%)';
                        dialogueBox.style.width = '80%';
                        dialogueBox.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                        dialogueBox.style.color = 'white';
                        dialogueBox.style.padding = '20px';
                        dialogueBox.style.borderRadius = '5px';
                        dialogueBox.style.fontFamily = 'Arial, sans-serif';
                        dialogueBox.style.fontSize = '18px';
                        dialogueBox.style.lineHeight = '1.5';
                        dialogueBox.style.display = 'none';
                        dialogueBox.style.zIndex = '1000';
                        dialogueBox.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5)';
                        dialogueBox.style.border = '1px solid rgba(255, 255, 255, 0.2)';
                        document.body.appendChild(dialogueBox);
                    }
                    
                    // Create skip button if it doesn't exist
                    if (!skipButton) {
                        skipButton = document.createElement('button');
                        skipButton.id = 'skip-button';
                        skipButton.innerText = 'Skip';
                        skipButton.style.position = 'absolute';
                        skipButton.style.bottom = '10px';
                        skipButton.style.right = '10%';
                        skipButton.style.padding = '5px 15px';
                        skipButton.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                        skipButton.style.color = 'white';
                        skipButton.style.border = '1px solid white';
                        skipButton.style.borderRadius = '5px';
                        skipButton.style.cursor = 'pointer';
                        skipButton.style.display = 'none';
                        skipButton.style.zIndex = '1001';
                        skipButton.addEventListener('click', skipCutscene);
                        document.body.appendChild(skipButton);
                    }
                }
                
                // Disable functions that trigger cutscenes
                function startIntroCutscene() {
    // Skip cutscene if player is continuing from a save and not at spawn position
    if (typeof savedPosition !== "undefined" && savedPosition && 
        (Math.abs(savedPosition.x) > 5 || Math.abs(savedPosition.z) > 5)) {
        console.log("Player continuing from save - skipping intro cutscene");
        return; // Skip the cutscene entirely
    }
    
    cutsceneActive = true;
    return; // Disabled for direct gameplay
}
                
                function advanceCutscene() {
    return; // Disabled for direct gameplay
}
                
                function skipCutscene() {
    return; // Disabled for direct gameplay
}
                
                // Disable story progress checks that would trigger cutscenes
                
                // Check game story progress based on player position
                function checkStoryProgress(position) {
    // Skip triggers if player loaded from a save and is already away from spawn
    if (typeof savedPosition !== "undefined" && savedPosition && 
        (Math.abs(position.x) > 5 || Math.abs(position.z) > 5)) {
        gameProgress.borderReached = true; // Prevent border trigger
        console.log("Player continuing from save - skipping story triggers");
        return;
    }
    
    // Only check for progress if we're in a phase where events can trigger
                    // Only check for progress if we're in a phase where events can trigger
                    if (gameProgress.storyPhase !== 'escape' || gameProgress.borderReached) {
                        return;
                    }
                    
                    // Border checkpoint location - use simple distance calculation to improve performance
                    const borderCheckpoint = {
                        x: 0,    // Center x-coordinate
                        z: 110,   // Changed from 120 to trigger event earlier
                        radius: 5 // Detection radius
                    };
                    
                    // Use squared distance for better performance (avoid expensive sqrt)
                    const dx = position.x - borderCheckpoint.x;
                    const dz = position.z - borderCheckpoint.z;
                    const squaredDist = dx*dx + dz*dz;
                    const squaredRadius = borderCheckpoint.radius * borderCheckpoint.radius;
                    
                    // If player is at the border checkpoint and it hasn't been triggered yet
                    if (squaredDist < squaredRadius && !gameProgress.eventInProgress && !document.getElementById("border-encounter")) {
                        console.log("Border checkpoint reached!");
                        
                        // Set flags to prevent retriggering
                        gameProgress.borderReached = true;
                        gameProgress.storyPhase = 'border';
                        
                        // Trigger UI immediately to avoid lag
                        triggerBorderEncounter();
                        
                        // Pause movement for the event
                        // cutsceneActive = false; // Kept disabled
                    }
                }
                
                // Trigger a story event at the border
                
function triggerBorderEncounter() {
    // Skip for continued games
    if (typeof savedPosition !== "undefined" && savedPosition && 
        (Math.abs(savedPosition.x) > 5 || Math.abs(savedPosition.z) > 5)) {
        console.log("Player continuing from save - skipping border encounter");
        return;
    }
    
    // Prevent multiple trigger
    // Prevent multiple trigger
    if (gameProgress.eventInProgress) return;
    gameProgress.eventInProgress = true;

    // Disable player controls during the event
    blocker.style.display = 'none';
    
    // Create border checkpoint UI
    const encounterContainer = document.createElement('div');
    encounterContainer.id = 'border-encounter';
    
    // Set styles
    Object.assign(encounterContainer.style, {
        position: 'absolute',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        width: '70%',
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        color: 'white',
        padding: '30px',
        borderRadius: '10px',
        textAlign: 'center',
        zIndex: '1000',
        opacity: '0',
        transition: 'opacity 0.3s ease-in'
    });
    
    // Prepare content
    const content = document.createDocumentFragment();
    
    // Add title
    const title = document.createElement('h2');
    title.textContent = 'Through the Shadows';
    title.style.marginBottom = '20px';
    content.appendChild(title);
    
    // Add description
    const description = document.createElement('p');
    description.innerHTML = 'Using the darkness as cover, you move carefully between guard posts and security cameras.';
    description.style.marginBottom = '30px';
    description.style.lineHeight = '1.5';
    content.appendChild(description);
    
    // Create options
    const optionsContainer = document.createElement('div');
    Object.assign(optionsContainer.style, {
        display: 'flex',
        flexDirection: 'column',
        gap: '15px'
    });
    
    // Add choice options with different colors
    
    // Option 1: Take the long route through completely dark areas
    const option1 = document.createElement('button');
    option1.textContent = 'Take the long route through completely dark areas';
    Object.assign(option1.style, {
        padding: '15px 20px',
        backgroundColor: '#445577',
        color: 'white',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
        fontSize: '16px'
    });
    
    option1.addEventListener('click', function() {
        // Determine outcome based on probability
        const success = Math.random() < 0.8;
        
        // Show outcome popup
        showOutcomePopup(
            success, 
            'Patiently moving through the darkest sections, you avoid all detection despite the longer journey time.', 
            'You lose your bearings in the pitch black and accidentally trigger a motion sensor hidden in the darkness.', 
            'success.html', 
            'game.html'
        );
        
        // Remove encounter UI
        encounterContainer.style.opacity = '0';
        setTimeout(() => encounterContainer.remove(), 300);
    });
    optionsContainer.appendChild(option1);

    // Option 2: Move quickly when guards look away
    const option2 = document.createElement('button');
    option2.textContent = 'Move quickly when guards look away';
    Object.assign(option2.style, {
        padding: '15px 20px',
        backgroundColor: '#557755',
        color: 'white',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
        fontSize: '16px'
    });
    
    option2.addEventListener('click', function() {
        // Determine outcome based on probability
        const success = Math.random() < 0.5;
        
        // Show outcome popup
        showOutcomePopup(
            success, 
            'With perfect timing, you dash between cover points whenever guards look away, making rapid progress through the checkpoint area.', 
            'You mistime one of your movements. A guard turns back unexpectedly and spots you mid-dash.', 
            'success.html', 
            'game.html'
        );
        
        // Remove encounter UI
        encounterContainer.style.opacity = '0';
        setTimeout(() => encounterContainer.remove(), 300);
    });
    optionsContainer.appendChild(option2);

    // Option 3: Create shadow distractions
    const option3 = document.createElement('button');
    option3.textContent = 'Create shadow distractions';
    Object.assign(option3.style, {
        padding: '15px 20px',
        backgroundColor: '#775544',
        color: 'white',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
        fontSize: '16px'
    });
    
    option3.addEventListener('click', function() {
        // Determine outcome based on probability
        const success = Math.random() < 0.6;
        
        // Show outcome popup
        showOutcomePopup(
            success, 
            'Using small objects to cast moving shadows elsewhere, you keep guards distracted while you slip by unnoticed.', 
            'A guard realizes the shadows are a distraction and scans the area more thoroughly, spotting you in your hiding place.', 
            'success.html', 
            'game.html'
        );
        
        // Remove encounter UI
        encounterContainer.style.opacity = '0';
        setTimeout(() => encounterContainer.remove(), 300);
    });
    optionsContainer.appendChild(option3);
    
    // Add options to content
    content.appendChild(optionsContainer);
    
    // Add all content at once
    encounterContainer.appendChild(content);
    document.body.appendChild(encounterContainer);
    
    // Force a reflow and fade in
    setTimeout(() => {
        encounterContainer.style.opacity = '1';
    }, 10);
}

// Function to show outcome popup
function showOutcomePopup(success, successText, failureText, successRedirect, failureRedirect) {
    // Create outcome popup
    const outcomeContainer = document.createElement('div');
    outcomeContainer.id = 'outcome-popup';
    
    // Set styles for the container
    Object.assign(outcomeContainer.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        zIndex: '10000',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        opacity: '0',
        transition: 'opacity 0.5s ease-in-out'
    });
    
    // Create popup content
    const popupContent = document.createElement('div');
    Object.assign(popupContent.style, {
        backgroundColor: success ? 'rgba(20, 40, 20, 0.95)' : 'rgba(40, 20, 20, 0.95)',
        color: 'white',
        padding: '30px',
        borderRadius: '10px',
        maxWidth: '500px',
        width: '80%',
        border: '2px solid ' + (success ? '#73ff73' : '#ff7373'),
        boxShadow: '0 0 20px ' + (success ? '#73ff73' : '#ff7373')
    });
    
    // Add title
    const title = document.createElement('h2');
    title.textContent = success ? 'Success!' : 'Failure!';
    title.style.color = success ? '#73ff73' : '#ff7373';
    title.style.marginBottom = '20px';
    
    // Add outcome text
    const outcomeText = document.createElement('p');
    outcomeText.textContent = success ? successText : failureText;
    outcomeText.style.marginBottom = '25px';
    outcomeText.style.lineHeight = '1.5';
    
    // Add continue button
    const continueButton = document.createElement('button');
    continueButton.textContent = success ? 'Continue' : 'Try Again';
    Object.assign(continueButton.style, {
        padding: '12px 20px',
        backgroundColor: success ? '#3b6c4a' : '#6c3b3b',
        color: 'white',
        border: 'none',
        borderRadius: '5px',
        cursor: 'pointer',
        fontSize: '16px',
        display: 'block',
        margin: '0 auto'
    });
    
    // Add click event
    continueButton.addEventListener('click', function() {
        // Redirect to appropriate page
        window.location.href = success ? successRedirect : failureRedirect;
    });
    
    // Assemble the popup
    popupContent.appendChild(title);
    popupContent.appendChild(outcomeText);
    popupContent.appendChild(continueButton);
    outcomeContainer.appendChild(popupContent);
    
    // Add to document
    document.body.appendChild(outcomeContainer);
    
    // Fade in
    setTimeout(() => {
        outcomeContainer.style.opacity = '1';
    }, 50);
}

                // Add pause menu button listeners
                document.getElementById('resume-game').addEventListener('click', function() {
                    togglePauseMenu(false);
                });
                
                document.getElementById('restart-game').addEventListener('click', function() {
                    window.location.reload();
                });

                document.getElementById('save-quit').addEventListener('click', function() {
                    saveGameAndQuit();
                });
                
                document.getElementById('return-home').addEventListener('click', function() {
                    window.location.href = 'index.html';
                });
